;----------------------------------------------------------------------------
; @(#)$CDS: assura version av4.1:Production:dfII6.1.8-64b:IC6.1.8-64b.500.1 08/29/19 22:32 (sj-ramneek) $
; sub-version 4.1_USR6_HF3
;----------------------------------------------------------------------------


;----------------------------------------------------------------------------
; RSF include(/pkg/xfab/XKIT/xh018/cadence/v8_0/assura/v8_0_1/Assura/XH018_1143/LVSinclude.rsf) Section
; Specified in the Assura UI
;----------------------------------------------------------------------------

; LVSinclude.rsf

avParameters(
?resolution 0.0005
?modifyHierarchy t
?textPriOnly t
?ercSetPwr ( ("*VDD*" "*vdd*") )
?ercSetGnd ( ("*GND*" "*gnd*" "*vss*" "*VSS*") )
)
avCompareRules(
	alwaysContinue()
	expandOnError( (instCount t) (reduce t) (swap t) )
        abortOnUnboundDevices(nil)
	verifyTopSchPins( (all keepFloatingPins) )
        verifyTopLayPins( (all keepFloatingPins) )
	formGate(none)
layout(
    ignoreDefaultPowerGround(t)
    resDevice( "s_res" ( "PLUS" "MINUS" nil) )
    filterDevice( "pcapacitor" )
    filterDevice( "presistor" short("PLUS" "MINUS") )
    filterDevice( "p_ddnw" )
    filterDevice( "p_ddnwmv" )
    filterDevice( "p_dhnw" )
    filterDevice( "p_dhpw" )
    filterDevice( "p_dipdnw" )
    filterDevice( "p_dipdnwmv" )
    filterDevice( "p_dnw" )
    filterDevice( "p_dnw3" )
    filterDevice( "p_dn" )
    filterDevice( "p_dn3" )
    filterDevice( "p_dnn3" )
    filterDevice( "p_dnhpw" )
    filterDevice( "p_dp" )
    filterDevice( "p_dp3" )
    filterDevice( "p_dpdnw" )
    filterDevice( "p_dpdnwmv" )
    filterDevice( "p_dphnw" )
    filterDevice( "p_dwhn" )
    filterDevice( "p_dndf" )
    filterDevice( "p_dpdwhn" )
    filterDevice( "p_dpwhn" )
    filterDevice( "p_dn3dpl" )
    filterDevice( "p_ddpldnw" )
    filterDevice( "p_dpdddnw" )
    filterDevice( "p_dpndf" )
    filterDevice( "p_dbn" )    
    filterDevice( "p_dn3sci" )
    filterDevice( "p_dscidnwmv" )
    ;;filterOptions( "X" ) ;no standard
    swapPins( "cmm3" "(f PLUS MINUS)")
    swapPins( "cmm4" "(f PLUS MINUS)")
    swapPins( "cmm4t" "(f PLUS MINUS)")
    swapPins( "cmm5t" "(f PLUS MINUS)")
    swapPins( "cmm6t" "(f PLUS MINUS)")
    swapPins( "cmmh3" "(f PLUS MINUS)")
    swapPins( "cmmh4" "(f PLUS MINUS)")
    swapPins( "cmmh4t" "(f PLUS MINUS)")
    swapPins( "cmmh5t" "(f PLUS MINUS)")
    swapPins( "cmmh6t" "(f PLUS MINUS)")
    swapPins( "cdmm4t" "(f PLUS MINUS)")
    swapPins( "cdmm4" "(f PLUS MINUS)")
    swapPins( "cdmmh4t" "(f PLUS MINUS)")
    swapPins( "cdmmh4" "(f PLUS MINUS)")
    swapPins( "ctmm5t" "(f PLUS MINUS)")
    swapPins( "ctmm5" "(f PLUS MINUS)")
    swapPins( "ctmmh5t" "(f PLUS MINUS)")
    swapPins( "ctmmh5" "(f PLUS MINUS)")
    swapPins( "csandwt3" "(f PLUS MINUS)")
    swapPins( "csandwt4" "(f PLUS MINUS)")
    swapPins( "csandwt5" "(f PLUS MINUS)")
    swapPins( "csf2p" "(f PLUS MINUS)")
    swapPins( "csf3" "(f PLUS MINUS)")
    swapPins( "csf3p" "(f PLUS MINUS)")
    swapPins( "csf4" "(f PLUS MINUS)")
    swapPins( "csf5" "(f PLUS MINUS)")
    swapPins( "csft4" "(f PLUS MINUS)")
    swapPins( "csft5" "(f PLUS MINUS)")
    swapPins( "csft6" "(f PLUS MINUS)")
    swapPins( "csf3a" "(f PLUS MINUS)")
    swapPins( "csf4a" "(f PLUS MINUS)")
    swapPins( "csf5a" "(f PLUS MINUS)")
    swapPins( "csft4a" "(f PLUS MINUS)")
    swapPins( "csft5a" "(f PLUS MINUS)")
    swapPins( "csft6a" "(f PLUS MINUS)")
    swapPins( "csf3b" "(f PLUS MINUS)")
    swapPins( "csf4b" "(f PLUS MINUS)")
    swapPins( "csf5b" "(f PLUS MINUS)")
    swapPins( "csft4b" "(f PLUS MINUS)")
    swapPins( "csft5b" "(f PLUS MINUS)")
    swapPins( "csft6b" "(f PLUS MINUS)")
    swapPins( "dn" "(f PLUS MINUS)")
    swapPins( "dn3" "(f PLUS MINUS)")
    swapPins( "dnn3" "(f PLUS MINUS)")
    swapPins( "dnw" "(f PLUS MINUS)")
    swapPins( "dnw3" "(f PLUS MINUS)")
    swapPins( "dp" "(f PLUS MINUS)")
    swapPins( "dp3" "(f PLUS MINUS)")
    swapPins( "ddnw" "(f PLUS MINUS)")
    swapPins( "ddnwmv" "(f PLUS MINUS)")
    swapPins( "dipdnw" "(f PLUS MINUS)")
    swapPins( "dipdnwmv" "(f PLUS MINUS)")
    swapPins( "dpdnw" "(f PLUS MINUS)")
    swapPins( "dpdnwmv" "(f PLUS MINUS)")
    swapPins( "dnhpw" "(f PLUS MINUS)")
    swapPins( "dphnw" "(f PLUS MINUS)")
    swapPins( "dhpw" "(f PLUS MINUS)")
    swapPins( "dhnw" "(f PLUS MINUS)")
    swapPins( "dwhn" "(f PLUS MINUS)")
    swapPins( "dpwhn" "(f PLUS MINUS)")
    swapPins( "dpdwhn" "(f PLUS MINUS)")
    swapPins( "dndf" "(f PLUS MINUS)")
    swapPins( "dsb" "(f PLUS MINUS)")
    swapPins( "dsba" "(f PLUS MINUS)")
    swapPins( "dnp20" "(f PLUS MINUS)")
    swapPins( "dpp20" "(f PLUS MINUS)")
    swapPins( "dpol" "(f PLUS MINUS)")
    swapPins( "dphoa" "(f PLUS MINUS)")
    swapPins( "dphob" "(f PLUS MINUS)")
    swapPins( "dphoc" "(f A C POLY1 NW LPOWER)")
    swapPins( "dphoc0" "(f A C POLY1 NW LPOWER)")
    swapPins( "dphocfp" "(f A C POLY1 NW LPOWER)")
    swapPins( "dphod" "(f A1 A2 C POLY1 NW LPOWER)")
    swapPins( "dphod0" "(f A1 A2 C POLY1 NW LPOWER)")
    swapPins( "dphodfp" "(f A1 A2 C POLY1 NW LPOWER)")
    swapPins( "dapda" "(f A C LPOWER)")
    swapPins( "dapda0" "(f A C LPOWER)")
    swapPins( "dspada" "(f A C PHOTON)")
    swapPins( "dspada0" "(f A C PHOTON)")
    swapPins( "nedi" "(f S D)")
    swapPins( "nedia" "(f S D)")
    swapPins( "ped2" "(f S D)")
    swapPins( "ped" "(f S D)")
    swapPins( "pmc" "(f S D)")
    swapPins( "nmc" "(f S D)")
    swapPins( "phv" "(f S D)")
    swapPins( "nhv" "(f S D)")
    swapPins( "nhvd" "(f S D)")
    swapPins( "nhv_bjt" "(f S D)")
    swapPins( "nhvd_bjt" "(f S D)")
    swapPins( "nedi_bjt" "(f S D)")
    swapPins( "nedia_bjt" "(f S D)")
    swapPins( "ped2_bjt" "(f S D)")
    swapPins( "ped_bjt" "(f S D)")
    swapPins( "pmc_bjt" "(f S D)")
    swapPins( "phv_bjt" "(f S D)")
    swapPins( "pmma_bjt" "(p S D)")
    swapPins( "pmmc_bjt" "(p S D)")
    swapPins( "phhv_bjt" "(p S D)")
    swapPins( "nedam" "(f S D)")
    swapPins( "pedam" "(f S D)")
    swapPins( "nedam_bjt" "(f S D)")
    swapPins( "pedam_bjt" "(f S D)")
    swapPins( "pedama" "(f S D)")
    swapPins( "pedama_bjt" "(f S D)")
    swapPins( "mosvc" "(f G NW SB)")
    swapPins( "mosvc3" "(f G NW SB)")
    swapPins( "mosvci" "(f G PW DNW SB)")
    swapPins( "mosvci_m" "(f G PW DNW SB)")
    swapPins( "mosvc3i" "(f G PW DNW SB)")
    swapPins( "mosvc3i_m" "(f G PW DNW SB)")
    swapPins( "cpod" "(f PLUS MINUS)")
    swapPins( "cpod3" "(f PLUS MINUS)")
    swapPins( "cpodhv" "(f PLUS MINUS)")
    swapPins( "dn3sci" "(f PLUS MINUS)")
    swapPins( "dscidnwmv" "(f PLUS MINUS)")
    swapPins( "cnn_otpa" "(f PLUS MINUS)")
    swapPins( "nha3m" "(f S D)")
    )
schematic(
    ignoreDefaultPowerGround(t)
    )
    
    hideBindWarnings(t)
    
)



;----------------------------------------------------------------------------
; avParameter Section
; Created by the Assura UI
;----------------------------------------------------------------------------

avParameters(
  ?inputLayout ( "df2" "Stimulator_IMP" )
  ?cellName "5bit_BinaryWeightedMirror_ST"
  ?viewName "layout"
  ?runName "5bit_BinaryWeightedMirror_ST_LVS"
  ?workingDirectory "./AssuraLVS"
  ?technology "XH018_1143"
  ?techLib "./assura_tech.lib"
  ?avrpt t
)




;----------------------------------------------------------------------------
; avCompareRules Section from Rules Files
; Specified in the Assura UI
;----------------------------------------------------------------------------

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; File:         compare.rul
;
; Description:  Assura XH018 LVS Rules
; Author:       Alexander Schael
; Created:      Aug 15 12:57 07
; Modified:     Jul 10 07:16 19 3467 schael
; Language:     Skill
; Package:      N/A
; MainFun:      N/A
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Revisions:
;
; Jul 10 07:15 19 (schael) aschael@sb21
;  update regarding PDS_018_03 Rel. 8.0.1
; Jan  3 11:52 18 (schael) aschael@sb21
;  fix missed nesvti_6, nesvti_m_6
; Nov 10 13:09 17 (schael) aschael@sb21
;  update regarding PDS_018_03 Rel. 7.0.1
; May 11 10:08 16 (schael) aschael@sb21
;  update regarding PDS_018_03 Rel. 6.2.1
;  compareDIO updated
; Sep 23 10:45 15 (schael) aschael@sb21
;  update regarding PDS_018_03 Rel. 6.1.1
; Jun 11 16:05 15 (schael) aschael@sb21
;  update regarding PDS_018_03 Rel. 6.0.1
;  fix csf3p issue
; Nov  4 13:21 14 (schael) aschael@sb21
;  internal issues, update parallelBJT&compareBJT
; Jun 30 15:15 14 (schael) aschael@sb21
;  update regarding PDS_018_03 Rel. 5.0.1
; Nov 27 13:19 12 (schael) aschael@sb21
;  update regarding PDS_018_03 Rel. 4.0.1
; Oct 19 14:05 12 (schael) aschael@sb21
;  change MIM names
; Apr  4 12:46 12 (schael) aschael@sb21
;  fix problem in parallelBjt*
; Dec 16 14:44 11 (schael) aschael@v01
;  update regarding PDS_018_03 Rel. 3.0.1
; Oct 20 07:15 11 (schael) aschael@v01
;  add qnvb
; Dec  9 11:01 10 (schael) aschael@v01
;  add new devices
; Jun 15 16:30 10 (schael) aschael@v01
;  fix parallelRES and add Multipliercheck in compareRES
;  fix parallelBJT_l (le)
; Jun  2 09:47 10 (schael) aschael@v01
;  add special ESDresistors
; Aug 28 12:40 09 (schael) aschael@v01
;  add Perimeter in compareCap & mergeParallelCap
; May 27 11:57 09 (schael) aschael@v01
;  update mergeParallel(BJT) & mergeParallel(CAP/MIMCAP) & mergeParallel(RES)
;  merge only if geometry is equal, support of Mult is possible now
; May 18 15:36 09 (schael) aschael@v01
;  change mergeSeries(RES) to noMerge
; Apr 22 15:40 09 (schael) aschael@v01
;  add cdmm, ctmm, nedia; tol in parallelMOS to < 1e-20
; Jan  7 12:33 09 (schael) aschael@v01
;  change tolerance in parallelMOS for l merge to zero
; May 21 14:17 08 (schael) aschael@v01
;  change back to parallelMOS (only if l is equal)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
/* ****************************************************************************
DISCLAIMER:
#  The information contained herein is provided by X-FAB Semiconductor
#  Foundries AG  on an "AS IS" basis without any warranty.
#
#  X-FAB Semiconductor Foundries AG disclaims any representation that
#  the information does not infringe any intellectual property rights or proprietary
#  rights of any third parties.  There are no other warranties given by
#  X-FAB, whether express, implied or statutory, including, without limitation,
#  implied warranties of merchantability and fitness for a particular purpose.

# In no event X-FAB will be liable or responsible for any expense, losses, damages,
# or action incurred or undertaken as a result of the receipt of the information.
#
#  X-FAB Semiconductor Foundries AG  reserves the right to make changes
#  to the information at any time and without notice.
**************************************************************************** */


avCompareRules(

  fileVer  = "v15.1";
  fileDate = "Jul 10, 2019"
  libVer  = "X-FAB XH018 Techfile Version"
  printf( "  \n" )
  printf(
   "*************************************************************** \n"
  )
  printf( "  \n" )
  printf(
    " X-FAB Assura Compare Rules file version %s updated on %s \n"
    fileVer fileDate
  )
  printf( " X-FAB Design Support\n" )
  printf( " \n" )
  printf(
   "*************************************************************** \n"
  )
  printf( " \n" )


; *********************************************************************
; Put tolerance values up front so they are easy to change
; *********************************************************************

; these are percentages

; MOS width, length

  mosW_lvsTol = 1.0
  mosL_lvsTol = 1.0

; RES w, r, l

  resW_lvsTol = 1.0
  resL_lvsTol = 1.0
  resR_lvsTol = 1.0

; BJT area

  bjtAREA_lvsTol = 1.0
  bjtLE_lvsTol = 1.0

; DIODE area

  diodeAREA_lvsTol = 5.0
  diodePERIM_lvsTol = 5.0
  dphoAREA_lvsTol = 1.0
  dphoPERIM_lvsTol = 1.0
  ;;dphoAREA_lvsTol = 10.0
  ;;dphoPERIM_lvsTol = 10.0

; MOSCAP w, l

  moscapW_lvsTol = 1.0
  moscapL_lvsTol = 1.0

; MIMCAP c

  mimcapC_lvsTol = 1.0
  mimcapA_lvsTol = 1.0

; CAP c

  capC_lvsTol = 1.0
  capA_lvsTol = 1.0

; *********************************************************************
; Define how devices are permuted (combined)
; *********************************************************************

; *****************************************************************
; Combine parallel MOS devices
; combines only if lengths are equal

  procedure( parallelMOS( mos1 mos2 )
    prog( ( parMos missing1 missing2 )
      
; set the output plist to nil

      parMos = ncons(nil)

; If m is not defined, set m to 1

;;      when( !mos1->m  mos1->m = float(1) )
;;      when( !mos2->m  mos2->m = float(1) )

; If W or L is missing, do not combine

      foreach( prop '( w l )
        unless( get( mos1 prop )
	   unless( get( mos1 upperCase(prop) )
	      missing1 = cons( prop missing1 )
	   )
        ) ;unless
        unless( get( mos2 prop )
	   unless( get( mos2 upperCase(prop) )
	      missing2 = cons( prop missing2 )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missing1 || missing2 )

        printf( "\n" )
        printf(
          "** Parallel MOS with missing parameters not combined:\n"
        )

        when( missing1
          printf(
            "   1st device: MOS missing parameters: %s \n"
            buildString( missing1 ",") )
        ) ;when
        when( !missing1
          printf(
            "   1st device: MOS with all parameters \n" )
        ) ;when

        when( missing2
          printf(
            "   2nd device: MOS missing parameters: %s \n"
            buildString( missing2 ",") )
        ) ;when
        when( !missing2
          printf(
            "   2nd device: MOS with all parameters \n" )
        ) ;when

        return( "doNotCombine" )
      )

; now we know that w, l and m are defined for both plists

; set variables to make typing easier and code simpler

      if( (mos1->m) then
	 M1 = float( mos1->m )
	 else
	 if( (mos1->M) then
	    M1 = float( mos1->M )
	 else
	    M1 = float(1)
	 )
      ) ; ** if mos1 **
      
      if( (mos1->w) then
	 W1 = float( mos1->w )
      else
	 if( (mos1->W) then
	    W1 = float( mos1->W )
	 )
      ) ; ** if mos1 **
      
      if( (mos1->l) then
	 L1 = float( mos1->l )
      else
	 if( (mos1->L) then
	    L1 = float( mos1->L )
	 )
      ) ; ** if mos1 **
      
      if( (mos2->m) then
	 M2 = float( mos2->m )
	 else
	 if( (mos2->M) then
	    M2 = float( mos2->M )
	 else
	    M2 = float(1)
	 )
      ) ; ** if mos2 **
      
      if( (mos2->w) then
	 W2 = float( mos2->w )
      else
	 if( (mos2->W) then
	    W2 = float( mos2->W )
	 )
      ) ; ** if mos2 **
      
      if( (mos2->l) then
	 L2 = float( mos2->l )
      else
	 if( (mos2->L) then
	    L2 = float( mos2->L )
	 )
      ) ; ** if mos2 **

; combine only if lengths are equal

      diffL = abs( L2 - L1 )
      
      ;;unless( diffL == 0  ;;0 could be an problem (skill)
      unless( diffL < 1e-20
	 
        return( "doNotCombine" )
      )

; Now combine parameters; make sure we set new L and M.
      
      parMos->w = float(W1 * M1 + W2 * M2)
      
      parMos->m = float(1.0)
      parMos->l = L1

; Report combining to the log file

      printf( "\n" )
      printf( "** Parallel MOS combined: \n" )

      printf("   1st device: L = %g W = %g m = %g \n"
        L1 W1 M1 )

      printf("   2nd device: L = %g W = %g m = %g \n"
        L2 W2 M2 )

      printf(
        "   Resulting: L = %g W = %g m = 1 \n" L1 parMos->w )

      return( parMos )

    )
  ) ;parallelMOS
  


;;;; parallelMOS_m

  procedure( parallelMOS_m( mos1 mos2 )
    prog( ( parMos missing1 missing2 )

; set the output plist to nil

      parMos = ncons(nil)

; If m is not defined, set m to 1

;;      when( !mos1->m  mos1->m = float(1) )
;;      when( !mos2->m  mos2->m = float(1) )

; If W or L is missing, do not combine

      foreach( prop '( w l )
        unless( get( mos1 prop )
	   unless( get( mos1 upperCase(prop) )
	      missing1 = cons( prop missing1 )
	   )
        ) ;unless
        unless( get( mos2 prop )
	   unless( get( mos2 upperCase(prop) )
	      missing2 = cons( prop missing2 )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missing1 || missing2 )

        printf( "\n" )
        printf(
          "** Parallel MOS with missing parameters not combined:\n"
        )

        when( missing1
          printf(
            "   1st device: MOS missing parameters: %s \n"
            buildString( missing1 ",") )
        ) ;when
        when( !missing1
          printf(
            "   1st device: MOS with all parameters \n" )
        ) ;when

        when( missing2
          printf(
            "   2nd device: MOS missing parameters: %s \n"
            buildString( missing2 ",") )
        ) ;when
        when( !missing2
          printf(
            "   2nd device: MOS with all parameters \n" )
        ) ;when

        return( "doNotCombine" )
      )

; now we know that w, l and m are defined for both plists

; set variables to make typing easier and code simpler

      if( (mos1->m) then
	 M1 = float( mos1->m )
	 else
	 if( (mos1->M) then
	    M1 = float( mos1->M )
	 else
	    M1 = float(1)
	 )
      ) ; ** if mos1 **
      
      if( (mos1->w) then
	 W1 = float( mos1->w )
      else
	 if( (mos1->W) then
	    W1 = float( mos1->W )
	 )
      ) ; ** if mos1 **
      
      if( (mos1->l) then
	 L1 = float( mos1->l )
      else
	 if( (mos1->L) then
	    L1 = float( mos1->L )
	 )
      ) ; ** if mos1 **
      
      if( (mos2->m) then
	 M2 = float( mos2->m )
	 else
	 if( (mos2->M) then
	    M2 = float( mos2->M )
	 else
	    M2 = float(1)
	 )
      ) ; ** if mos2 **
      
      if( (mos2->w) then
	 W2 = float( mos2->w )
      else
	 if( (mos2->W) then
	    W2 = float( mos2->W )
	 )
      ) ; ** if mos2 **
      
      if( (mos2->l) then
	 L2 = float( mos2->l )
      else
	 if( (mos2->L) then
	    L2 = float( mos2->L )
	 )
      ) ; ** if mos2 **

; combine only if lengths are equal

      diffL = abs( L2 - L1 )

      unless( diffL < .005e-6
        return( "doNotCombine" )
      )

; cmbine only if widths are equal

      diffW = abs( W2 - W1 )
      unless(  diffW < 0.1e-6
	 return( "doNotCombine" )
      )
      
; Now combine parameters; make sure we set new W,L and M.

      parMos->w = float(W1 * M1 + W2 * M2) / float(M1 + M2)

      parMos->m = float( M1 + M2 )
      parMos->l = ( ( L1 + L2 ) / 2 )

; Report combining to the log file

      printf( "\n" )
      printf( "** Parallel MOS combined: \n" )

      printf("   1st device: L = %g W = %g m = %g \n"
        L1 W1 M1 )

      printf("   2nd device: L = %g W = %g m = %g \n"
        L2 W2 M2 )

      printf(
        "   Resulting: L = %g W = %g m = %g \n" parMos->l parMos->w parMos->m)

      return( parMos )

    )
  ) ;parallelMOS_m

; *****************************************************************
; combine parallel resistors

  procedure( parallelRES( res1 res2 )
    prog( (parRes missing1 missing2)

; set the output plist to nil
      parRes = ncons(nil)

; If m (m factor) is missing, set it to 1

;;      when( !res1->m  res1->m = 1 )
;;      when( !res2->m  res2->m = 1 )

; If W, L or R is missing, do not combine

      ;foreach( prop '( w r l)
      foreach( prop '( w l)
        unless( get( res1 prop )
	   unless( get( res1 upperCase(prop) )
	      missing1 = cons( prop missing1 )
	   )
        ) ;unless
        unless( get( res2 prop )
	   unless( get( res2 upperCase(prop) )
	      missing2 = cons( prop missing2 )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missing1 || missing2 )

        printf( "\n" )
        printf(
          "** Parallel RES with missing parameters not combined:\n"
        )

        when( missing1
          printf(
            "   1st device: Res missing parameters: %s \n"
            buildString( missing1 ",") )
        ) ;when
        when( !missing1
          printf(
            "   1st device: Res with all parameters \n" )
        ) ;when

        when( missing2
          printf(
            "   2nd device: Res missing parameters: %s \n"
            buildString( missing2 ",") )
        ) ;when
        when( !missing2
          printf(
            "   2nd device: Res with all parameters \n" )
        ) ;when

        return( "doNotCombine" )
      )

; now we know that w, r and m are defined for both plists

; set variables to make typing easier and code simpler

      if( (res1->m) then
	 M1 = float( res1->m )
	 else
	 if( (res1->M) then
	    M1 = float( res1->M )
	 else
	    M1 = float(1)
	 )
      ) ; ** if res1 **
      
      if( (res1->w) then
	 W1 = float( res1->w )
      else
	 if( (res1->W) then
	    W1 = float( res1->W )
	 )
      ) ; ** if res1 **
      
      if( (res1->l) then
	 L1 = float( res1->l )
      else
	 if( (res1->L) then
	    L1 = float( res1->L )
	 )
      ) ; ** if res1 **

;      if( (res1->r) then
;	 R1 = float( res1->r )
;      else
;	 if( (res1->R) then
;	    R1 = float( res1->R )
;	 )
;      ) ; ** if res1 **
      
      if( (res2->m) then
	 M2 = float( res2->m )
	 else
	 if( (res2->M) then
	    M2 = float( res2->M )
	 else
	    M2 = float(1)
	 )
      ) ; ** if res2 **
      
      if( (res2->w) then
	 W2 = float( res2->w )
      else
	 if( (res2->W) then
	    W2 = float( res2->W )
	 )
      ) ; ** if res2 **
      
      if( (res2->l) then
	 L2 = float( res2->l )
      else
	 if( (res2->L) then
	    L2 = float( res2->L )
	 )
      ) ; ** if res2 **

;       if( (res2->r) then
;	 R2 = float( res2->r )
;      else
;	 if( (res2->R) then
;	    R2 = float( res2->R )
;	 )
;      ) ; ** if res2 **
      

; Combine only if difference in width is < 0.005 um

      diffW = abs( W2 - W1 )
      diffL = abs( L2 - L1 )
      when( diffW >= 0.005e-6 
        printf( "\n" )
        printf(
          "** Parallel RES with unequal W not combined\n" )
        printf("   1st device: W = %g L = %g \n" W1 L1 )
        printf("   2nd device: W = %g L = %g \n" W2 L2 )

        return("doNotCombine")
      )
      when( diffL >= 0.005e-6 
        printf( "\n" )
        printf(
          "** Parallel RES with unequal L not combined\n" )
        printf("   1st device: W = %g L = %g \n" W1 L1 )
        printf("   2nd device: W = %g L = %g \n" W2 L2 )

        return("doNotCombine")
      )

; combine parameters
; correct for m-factor here

      ;;R1m  = R1/M1
      ;;R2m  = R2/M2
      ;newR = (R1m * R2m) / (R1m + R2m)
      ;;L1m  = L1/M1
      ;;L2m  = L2/M2
      ;;newL = (L1m * L2m) / (L1m + L2m)
      newM = (M1 + M2)
      newL = L1
      newW = W1

      parRes->w = newW
      ;parRes->r = newR
      parRes->l = newL
      ;;parRes->m = float( 1 )
      parRes->m = newM

      printf( "\n" )
      printf( "** Parallel resistors combined: \n" )
      printf( "   1st device: W = %g L = %g  \n" W1 L1 )
      printf( "   2nd device: W = %g L = %g  \n" W2 L2 )

      printf(
        "   Resulting: W = %g L = %g m = %g\n" newW newL newM
      )

      return(parRes)

    ) ;prog
  ) ;procedure( parallelRES )


; *****************************************************************
; combine series resistors


; *****************************************************************
; combine parallel moscaps
; moscaps with different l's are not combined

  procedure( parallelMOSCAP( moscap1 moscap2 )
    prog( (parCap missing1 missing2)

; set the output plist to nil

      parCap = ncons(nil)

; If m (m factor) is missing, set it to 1

;;      when( !moscap1->m  moscap1->m = 1 )
;;      when( !moscap2->m  moscap2->m = 1 )

; If W or L is missing, do not combine

      foreach( prop '( w l )
        unless( get( moscap1 prop )
	   unless( get( moscap1 upperCase(prop) )
	      missing1 = cons( prop missing1 )
	   )
        ) ;unless
        unless( get( moscap2 prop )
	   unless( get( moscap2 upperCase(prop) )
	      missing2 = cons( prop missing2 )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missing1 || missing2 )

        printf( "\n" )
        printf(
          "** Parallel MOSCAP with missing parameters not combined:\n"
        )

        when( missing1
          printf(
            "   1st device: moscap missing parameters: %s \n"
            buildString( missing1 ",") )
        ) ;when
        when( !missing1
          printf(
            "   1st device: moscap with all parameters \n" )
        ) ;when

        when( missing2
          printf(
            "   2nd device: moscap missing parameters: %s \n"
            buildString( missing2 ",") )
        ) ;when
        when( !missing2
          printf(
            "   2nd device: moscap with all parameters \n" )
        ) ;when

        return( "doNotCombine" )
      )

; now we know that w, l and m are defined for both plists

; set variables to make typing easier and code simpler

      if( (moscap1->m) then
	 M1 = float( moscap1->m )
	 else
	 if( (moscap1->M) then
	    M1 = float( moscap1->M )
	 else
	    M1 = float(1)
	 )
      ) ; ** if moscap1 **
      
      if( (moscap1->w) then
	 W1 = float( moscap1->w )
      else
	 if( (moscap1->W) then
	    W1 = float( moscap1->W )
	 )
      ) ; ** if moscap1 **
      
      if( (moscap1->l) then
	 L1 = float( moscap1->l )
      else
	 if( (moscap1->L) then
	    L1 = float( moscap1->L )
	 )
      ) ; ** if moscap1 **
      
      if( (moscap2->m) then
	 M2 = float( moscap2->m )
	 else
	 if( (moscap2->M) then
	    M2 = float( moscap2->M )
	 else
	    M2 = float(1)
	 )
      ) ; ** if moscap2 **
      
      if( (moscap2->w) then
	 W2 = float( moscap2->w )
      else
	 if( (moscap2->W) then
	    W2 = float( moscap2->W )
	 )
      ) ; ** if moscap2 **
      
      if( (moscap2->l) then
	 L2 = float( moscap2->l )
      else
	 if( (moscap2->L) then
	    L2 = float( moscap2->L )
	 )
      ) ; ** if moscap2 **

; Combine only if difference in length is < 0.005 um

      diffL = abs( L2 - L1 )

      when( diffL >= 0.005e-6
        printf( "\n" )
        printf("** Parallel moscap with unequal L not combined\n" )

        printf("   1st device: L = %g W = %g \n" L1 W1 )
        printf("   2nd device: L = %g W = %g \n" L2 W2 )

        return("doNotCombine")
      )

; combine parameters
; correct for m-factor here

      newW   = W1 * M1 + W2 * M2
      newL   = L1

      parCap->w = newW
      parCap->l = newL
      parCap->m = float(1)

; Report combining to the log file

      printf( "\n" )
      printf( "** Parallel moscap combined \n" )

      printf("   1st device: L = %g W = %g \n" L1 W1 )
      printf("   2nd device: L = %g W = %g \n" L2 W2 )

      printf(
        "   Resulting: L = %g W = %g m = 1 \n" newL newW )

      return(parCap)

    ) ;prog
  ) ;procedure( parallelMOSCAP )


; *****************************************************************
; combine parallel MIM caps

  procedure( parallelMIMCAP( mimcap1 mimcap2 )
    prog( (parCap missing1 missing2)
  
; set the output plist to nil

      parCap = ncons(nil)

; If m (m factor) is missing, set it to 1

;;      when( !mimcap1->m  mimcap1->m = 1 )
;;      when( !mimcap2->m  mimcap2->m = 1 )

; If C is missing, do not combine

      foreach( prop '( area )
        unless( get( mimcap1 prop )
	   unless( get( mimcap1 upperCase(prop) )
	      missing1 = cons( prop missing1 )
	   )
        ) ;unless
        unless( get( mimcap2 prop )
	   unless( get( mimcap2 upperCase(prop) )
	      missing2 = cons( prop missing2 )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missing1 || missing2 )

        printf( "\n" )
        sprintf( msg
          "Parallel MIMCAPs with missing parameters not combined"
        )
        printf( "** %s: \n" msg )

        when( missing1
          printf(
            "   1st device: mimcap missing parameters: %s \n"
            buildString( missing1 ",") )
        ) ;when
        when( !missing1
          printf(
            "   1st device: mimcap with all parameters \n" )
        ) ;when

        when( missing2
          printf(
            "   2nd device: mimcap missing parameters: %s \n"
            buildString( missing2 ",") )
        ) ;when
        when( !missing2
          printf(
            "   2nd device: mimcap with all parameters \n" )
        ) ;when

        return( "doNotCombine" )
      )

; now we know that c and m are defined for both plists

; set variables to make typing easier and code simpler

      if( (mimcap1->m) then
	 M1 = float( mimcap1->m )
	 else
	 if( (mimcap1->M) then
	    M1 = float( mimcap1->M )
	 else
	    M1 = float(1)
	 )
      ) ; ** if mimcap1 **
      
      if( (mimcap1->area) then
	 A1 = float( mimcap1->area )
      else
	 if( (mimcap1->AREA) then
	    A1 = float( mimcap1->AREA )
	 )
      ) ; ** if mimcap1 **

      if( (mimcap2->m) then
	 M2 = float( mimcap2->m )
	 else
	 if( (mimcap2->M) then
	    M2 = float( mimcap2->M )
	 else
	    M2 = float(1)
	 )
      ) ; ** if mimcap2 **
      
      if( (mimcap2->area) then
	 A2 = float( mimcap2->area )
      else
	 if( (mimcap2->AREA) then
	    A2 = float( mimcap2->AREA )
	 )
      ) ; ** if mimcap2 **

; combine only if areas per device are equal

      diffA = abs( A2 - A1 )

      unless( diffA < .005e-12
        return( "doNotCombine" )
      )

; combine parameters
; correct for m-factor here

      ;;newA   = A1 * M1 + A2 * M2
          
      parCap->area = A2
      newM = M1 + M2
      parCap->m = newM

; Report combining to the log file

      printf( "\n" )
      printf( "** Parallel mimcap combined \n" )

      printf("   1st device: area = %g m = %g\n" A1 M1)
      printf("   2nd device: area = %g m = %g\n" A2 M2)

      printf(
        "   Resulting: area = %g m = %g \n" A2 newM)

      return(parCap)

    ) ;prog
  ) ;procedure( parallelMIMCAP )


; *****************************************************************
; combine parallel Caps

  procedure( parallelCAP( cap1 cap2 )
    prog( (parCap missing1 missing2)
  
; set the output plist to nil

      parCap = ncons(nil)

; If m (m factor) is missing, set it to 1

;;      when( !mimcap1->m  cap1->m = 1 )
;;      when( !mimcap2->m  cap2->m = 1 )

; If C is missing, do not combine

      foreach( prop '( area perimeter)
        unless( get( cap1 prop )
	   unless( get( cap1 upperCase(prop) )
	      missing1 = cons( prop missing1 )
	   )
        ) ;unless
        unless( get( cap2 prop )
	   unless( get( mimcap2 upperCase(prop) )
	      missing2 = cons( prop missing2 )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missing1 || missing2 )

        printf( "\n" )
        sprintf( msg
          "Parallel CAPs with missing parameters not combined"
        )
        printf( "** %s: \n" msg )

        when( missing1
          printf(
            "   1st device: cap missing parameters: %s \n"
            buildString( missing1 ",") )
        ) ;when
        when( !missing1
          printf(
            "   1st device: cap with all parameters \n" )
        ) ;when

        when( missing2
          printf(
            "   2nd device: cap missing parameters: %s \n"
            buildString( missing2 ",") )
        ) ;when
        when( !missing2
          printf(
            "   2nd device: cap with all parameters \n" )
        ) ;when

        return( "doNotCombine" )
      )

; now we know that c and m are defined for both plists

; set variables to make typing easier and code simpler

      if( (cap1->m) then
	 M1 = float( cap1->m )
	 else
	 if( (cap1->M) then
	    M1 = float( cap1->M )
	 else
	    M1 = float(1)
	 )
      ) ; ** if cap1 **
      
      if( (cap1->area) then
	 A1 = float( cap1->area )
      else
	 if( (cap1->AREA) then
	    A1 = float( cap1->AREA )
	 )
      ) ; ** if cap1 **

      if( (cap1->perimeter) then
	 P1 = float( cap1->perimeter )
      else
	 if( (cap1->PERIMETER) then
	    P1 = float( cap1->PERIMETER )
	 )
      ) ; ** if cap1 **

      if( (cap2->m) then
	 M2 = float( cap2->m )
	 else
	 if( (cap2->M) then
	    M2 = float( cap2->M )
	 else
	    M2 = float(1)
	 )
      ) ; ** if cap2 **
      
      if( (cap2->area) then
	 A2 = float( cap2->area )
      else
	 if( (cap2->AREA) then
	    A2 = float( cap2->AREA )
	 )
      ) ; ** if cap2 **

      if( (cap2->perimeter) then
	 P2 = float( cap2->perimeter )
      else
	 if( (cap2->PERIMETER) then
	    P2 = float( cap2->PERIMETER )
	 )
      ) ; ** if cap2 **

; combine only if areas per device are equal

      diffA = abs( A2 - A1 )
      diffP = abs( P2 - P1 )

      unless( diffA < .005e-12
        return( "doNotCombine" )
      )
      unless( diffP < .005e-12
        return( "doNotCombine" )
      )
      
; combine parameters
; correct for m-factor here

      ;;newA   = A1 * M1 + A2 * M2

      parCap->area = A2
      parCap->perimeter = P2
      newM = M1 + M2
      parCap->m = newM

; Report combining to the log file

      printf( "\n" )
      printf( "** Parallel cap combined \n" )

      printf("   1st device: area = %g perimeter = %g m = %g\n" A1 P1 M1)
      printf("   2nd device: area = %g perimeter = %g m = %g\n" A2 P2 M2)

      printf(
        "   Resulting: area = %g perimeter = %g m = %g \n" A2 P2 newM)

      return(parCap)

    ) ;prog
  ) ;procedure( parallelCAP )


; *****************************************************************
; Combine parallel Bipolar
; The only parameters are area, m

  procedure( parallelBJT( bjt1 bjt2 )
    ;;prog( ( parBjt missing1 missing2 )
    prog( ()

; set the output plist to nil

      parBjt = ncons(nil)

; If m (m factor) is missing, set it to 1

;;      when( !bjt1->m  bjt1->m = 1 )
;;      when( !bjt2->m  bjt2->m = 1 )

; If area is missing, do not combine
; foreach is not necessary since there is only one parameter
; the generic form is kept for easy expansion
/*
      foreach( prop '( area )
        unless( get( bjt1 prop )
	   unless( get( bjt1 upperCase(prop) )
	      missing1 = cons( prop missing1 )
	   )
        ) ;unless
        unless( get( bjt2 prop )
	   unless( get( bjt2 upperCase(prop) )
	      missing2 = cons( prop missing2 )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missing1 || missing2 )

        printf( "\n" )
        printf(
          "** Parallel BJT with missing area not combined:\n"
        )

        when( missing1
          printf(
            "   1st device: BJT missing parameters: %s \n"
            buildString( missing1 ",") )
        ) ;when
        when( !missing1
          printf(
            "   1st device: BJT with all parameters \n" )
        ) ;when

        when( missing2
          printf(
            "   2nd device: BJT missing parameters: %s \n"
            buildString( missing2 ",") )
        ) ;when
        when( !missing2
          printf(
            "   2nd device: BJT with all parameters \n" )
        ) ;when

        return( "doNotCombine" )
      )
*/
; now we know that area and m are defined for both plists

; set variables to make typing easier and code simpler

      if( (bjt1->m) then
	 M1 = float( bjt1->m )
	 else
	 if( (bjt1->M) then
	    M1 = float( bjt1->M )
	 else
	    M1 = float(1)
	 )
      ) ; ** if bjt1 **
/*      
      if( (bjt1->area) then
	 area1 = float( bjt1->area )
      else
	 if( (bjt1->AREA) then
	    area1 = float( bjt1->AREA )
	 )
      ) ; ** if bjt1 **
*/
      if( (bjt2->m) then
	 M2 = float( bjt2->m )
	 else
	 if( (bjt2->M) then
	    M2 = float( bjt2->M )
	 else
	    M2 = float(1)
	 )
      ) ; ** if bjt2 **
/*      
      if( (bjt2->area) then
	 area2 = float( bjt2->area )
      else
	 if( (bjt2->AREA) then
	    area2 = float( bjt2->AREA )
	 )
      ) ; ** if bjt2 **
*/

; combine only if areas per device are equal

      ;;diffA = abs( area2 - area1 )

      ;;unless( diffA < .005e-12
      ;;  return( "doNotCombine" )
      ;;)

; Now combine parameters

; save the area per emitter as the new area
; save the sum of M1 and M2 as the new m

; This is necessary because we can have more than two
;   devices in parallel; if we just saved the total area
;   we could combine the first two devices but not three.

      ;;parBjt->area = area2
      newM = M1 + M2
      parBjt->m = newM

      printf( "\n" )
      printf( "** Parallel BJT combined: \n" )

      ;;printf( "   1st device: area = %g m = %g \n" area1 M1 )
      ;;printf( "   2nd device: area = %g m = %g \n" area2 M2 )
      printf( "   1st device: m = %g \n" M1 )
      printf( "   2nd device: m = %g \n" M2 )

      ;;printf( "   Resulting: area = %g m = %g \n" area2 newM )
      printf( "   Resulting: m = %g \n" newM )
    

      return(parBjt)

    ) ;prog
  ) ;procedure


; *****************************************************************
; Combine parallel Bipolar
; The only parameters are Emitter length, m

  procedure( parallelBJT_l( bjt1 bjt2 )
    prog( ( parBjt missing1 missing2 )

; set the output plist to nil

      parBjt = ncons(nil)

; If m (m factor) is missing, set it to 1

;;      when( !bjt1->m  bjt1->m = 1 )
;;      when( !bjt2->m  bjt2->m = 1 )

; If area is missing, do not combine
; foreach is not necessary since there is only one parameter
; the generic form is kept for easy expansion

      foreach( prop '( le )
        unless( get( bjt1 prop )
	   unless( get( bjt1 upperCase(prop) )
	      missing1 = cons( prop missing1 )
	   )
        ) ;unless
        unless( get( bjt2 prop )
	   unless( get( bjt2 upperCase(prop) )
	      missing2 = cons( prop missing2 )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missing1 || missing2 )

        printf( "\n" )
        printf(
          "** Parallel BJT with missing Emitter Length not combined:\n"
        )

        when( missing1
          printf(
            "   1st device: BJT missing parameters: %s \n"
            buildString( missing1 ",") )
        ) ;when
        when( !missing1
          printf(
            "   1st device: BJT with all parameters \n" )
        ) ;when

        when( missing2
          printf(
            "   2nd device: BJT missing parameters: %s \n"
            buildString( missing2 ",") )
        ) ;when
        when( !missing2
          printf(
            "   2nd device: BJT with all parameters \n" )
        ) ;when

        return( "doNotCombine" )
      )

; now we know that area and m are defined for both plists

; set variables to make typing easier and code simpler

      if( (bjt1->m) then
	 M1 = float( bjt1->m )
	 else
	 if( (bjt1->M) then
	    M1 = float( bjt1->M )
	 else
	    M1 = float(1)
	 )
      ) ; ** if bjt1 **
      
      if( (bjt1->le) then
	 le1 = float( bjt1->le )
      else
	 if( (bjt1->LE) then
	    le1 = float( bjt1->LE )
	 )
      ) ; ** if bjt1 **

      if( (bjt2->m) then
	 M2 = float( bjt2->m )
	 else
	 if( (bjt2->M) then
	    M2 = float( bjt2->M )
	 else
	    M2 = float(1)
	 )
      ) ; ** if bjt2 **
      
      if( (bjt2->le) then
	 le2 = float( bjt2->le )
      else
	 if( (bjt2->LE) then
	    le2 = float( bjt2->LE )
	 )
      ) ; ** if bjt2 **


; combine only if areas per device are equal

      diffA = abs( le2 - le1 )

      unless( diffA < .005e-12
        return( "doNotCombine" )
      )

; Now combine parameters

; save the length per emitter as the new area
; save the sum of M1 and M2 as the new m

; This is necessary because we can have more than two
;   devices in parallel; if we just saved the total area
;   we could combine the first two devices but not three.

      parBjt->le = le2
      newM = M1 + M2
      parBjt->m = newM

      printf( "\n" )
      printf( "** Parallel BJT combined: \n" )

      printf( "   1st device: le = %g m = %g \n" le1 M1 )
      printf( "   2nd device: le = %g m = %g \n" le2 M2 )

      printf( "   Resulting: le = %g m = %g \n" le2 newM )

      return(parBjt)

    ) ;prog
  ) ;procedure


; *****************************************************************
; combine parallel diodes

  procedure( parallelDIO( dio1 dio2 )
    prog( ( parDio missing1 missing2 )

; set the output plist to nil
      parDio = ncons(nil)

; If m (m factor) is missing, set it to 1

;;      when( !dio1->m  dio1->m = 1 )
;;      when( !dio2->m  dio2->m = 1 )

; If area is missing, do not combine
; foreach is not necessary since there is only one parameter
; the generic form is kept for easy expansion

      foreach( prop '( area pj )
        unless( get( dio1 prop )
	   unless( get( dio1 upperCase(prop) ) 
	      missing1 = cons( prop missing1 )
	   )
        ) ;unless
        unless( get( dio2 prop )
	   unless( get( dio2 upperCase(prop) )
	      missing2 = cons( prop missing2 )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missing1 || missing2 )

        printf( "\n" )
        printf(
          "** Parallel DIODE with missing area not combined:\n" )

        when( missing1
          printf(
            "   1st device: Diode missing parameters: %s \n"
            buildString( missing1 ",") )
        ) ;when
        when( !missing1
          printf(
            "   1st device: Diode with all parameters \n" )
        ) ;when

        when( missing2
          printf(
            "   2nd device: Diode missing parameters: %s \n"
            buildString( missing2 ",") )
        ) ;when
        when( !missing2
          printf(
            "   2nd device: Diode with all parameters \n" )
        ) ;when

        return( "doNotCombine" )
      )

; now we know that area and m are defined for both plists

; set variables to make typing easier and code simpler

      if( (dio1->m) then
	 M1 = float( dio1->m )
	 else
	 if( (dio1->M) then
	    M1 = float( dio1->M )
	 else
	    M1 = float(1)
	 )
      ) ; ** if dio1 **
      
      if( (dio1->area) then
	 area1 = float( dio1->area )
      else
	 if( (dio1->AREA) then
	    area1 = float( dio1->AREA )
	 )
      ) ; ** if dio1 **

      if( (dio1->pj) then
	 perim1 = float( dio1->pj )
      else
	 if( (dio1->PJ) then
	    perim1 = float( dio1->PJ )
	 )
      ) ; ** if dio1 **

      if( (dio2->m) then
	 M2 = float( dio2->m )
	 else
	 if( (dio2->M) then
	    M2 = float( dio2->M )
	 else
	    M2 = float(1)
	 )
      ) ; ** if dio2 **
      
      if( (dio2->area) then
	 area2 = float( dio2->area )
      else
	 if( (dio2->AREA) then
	    area2 = float( dio2->AREA )
	 )
      ) ; ** if dio2 **

      if( (dio2->pj) then
	 perim2 = float( dio2->pj )
      else
	 if( (dio2->PJ) then
	    perim2 = float( dio2->PJ )
	 )
      ) ; ** if dio2 **


; Now combine parameters; set new m = 1

      newarea = area1*M1 + area2*M2
      newperim = perim1*M1 +perim2*M2
      parDio->area = newarea
      parDio->pj = newperim
      parDio->m = float(1)

      printf( "\n" )
      printf( "** Parallel Diode combined: \n" )


      printf( "   1st device: area = %g perim = %g m = %g \n" area1 perim1 M1 )
      printf( "   2nd device: area = %g perim = %g m = %g \n" area2 perim2 M2 )

      printf( "   Resulting: area = %g perim = %g m = 1 \n" newarea newperim)

      return( parDio )

    ) ;prog
  ) ;parallelDIO


; *********************************************************************
; Define how device parameters are compared
; *********************************************************************

; *****************************************************************
; Compare MOS device properties
  procedure( compareMOS( layPlist, schPlist )
    prog( (missingLay missingSch)
      
; If m (m factor) is missing, set it to 1

;;      when( !layPlist->m  layPlist->m = 1 )
;;      when( !schPlist->m  schPlist->m = 1 )     

; If W or L is missing generate a parameter mismatch

      foreach( prop '( w l )
        unless( get( layPlist prop )
	   unless( get( layPlist upperCase(prop) )
	      missingLay = cons( prop missingLay )
	   )
        ) ;unless
        unless( get( schPlist prop )
	   unless( get( schPlist upperCase(prop) )
	      missingSch = cons( prop missingSch )
	   )
	   ;;missingSch = cons( prop missingSch )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missingLay || missingSch )

	 when( missingSch
	    sprintf( msg1 "Err: Sch MOS missing params: %s"
	       buildString( missingSch ",") )
	 ) ;when
	 when( !missingSch
	    sprintf( msg1 ""
	    )
	 ) ;when

	 when( missingLay
	    sprintf( msg2 "Err: Lay MOS missing params: %s"
	       buildString( missingLay ",") )
	 ) ;when
	 when( !missingLay
	    sprintf( msg2 ""
	    )
	 ) ;when

	sprintf( msg "Err: %s ; %s" msg1 msg2 )
        return( msg )
      )

; now we know that w, l and m are defined for both plists

      if( (layPlist->m) then
	 layM = layPlist->m
	 else
	 if( (layPlist->M) then
	    layM = layPlist->M
	 else
	    layM = 1
	 )
      ) ; ** if layPlist **
      
      if( (layPlist->w) then
	 layW = float( layM * layPlist->w )
      else
	 if( (layPlist->W) then
	    layW = float( layM * layPlist->W )
	 )
      ) ; ** if layPlist **
      
      if( (layPlist->l) then
	 layL = float( layPlist->l )
      else
	 if( (layPlist->L) then
	    layL = float( layPlist->L )
	 )
      ) ; ** if layPlist **
      
      if( (schPlist->m) then
	 schM = schPlist->m
	 else
	 if( (schPlist->M) then
	    schM = schPlist->M
	 else
	    schM = 1
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->w) then
	 schW = float( schM * schPlist->w )
      else
	 if( (schPlist->W) then
	    schW = float( schM * schPlist->W )
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->l) then
	 schL = float( schPlist->l )
      else
	 if( (schPlist->L) then
	    schL = float( schPlist->L )
	 )
      ) ; ** if schPlist **

      diffW = 100 * (abs( layW - schW ) / schW )
      diffL = 100 * (abs( layL - schL ) / schL )

      Werr = nil
      Lerr = nil

      when( diffW > mosW_lvsTol Werr = t
	 sprintf(msg
        "Err: MOS Sch W %g; Lay W %g"
        schW layW
	 )
      ) ; ** when diffW **
      when( diffL > mosL_lvsTol Lerr = t
	 sprintf(msg
        "Err: MOS Sch L %g; Lay L %g"
        schL layL
	 )
      ) ; ** when diffL **
      when( diffL > mosL_lvsTol Lerr = t && diffW > mosW_lvsTol Werr = t
	 sprintf(
	    msg
	    "Err: MOS Sch L/W %g %g; Lay L/W %g %g"
	    schL schW layL layW
	 )
      ) ; ** when diffL **
      

; if no errors return nil

      when( !Werr && !Lerr  return(nil) )

; now we know there is a parameter error

      ;;sprintf(
      ;;  msg
      ;;  "Err: MOS Sch L/W %g %g; Lay L/W %g %g"
      ;;  schL schW layL layW
      ;;)
          
      return( msg )

   ) ; end prog
  ) ; end compareMOS

;;; compareMOS_m

  procedure( compareMOS_m( layPlist, schPlist )
    prog( (missingLay missingSch)
      
; If m (m factor) is missing, set it to 1

;;      when( !layPlist->m  layPlist->m = 1 )
;;      when( !schPlist->m  schPlist->m = 1 )

; If W or L is missing generate a parameter mismatch

       foreach( prop '( w l )
        unless( get( layPlist prop )
	   unless( get( layPlist upperCase(prop) )
	      missingLay = cons( prop missingLay )
	   )
        ) ;unless
        unless( get( schPlist prop )
	   unless( get( schPlist upperCase(prop) )
	      missingSch = cons( prop missingSch )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missingLay || missingSch )

	 when( missingSch
	    sprintf( msg1 "Err: Sch MOS missing params: %s"
	       buildString( missingSch ",") )
	 ) ;when
	 when( !missingSch
	    sprintf( msg1 ""
	    )
	 ) ;when
	 
	 when( missingLay
	    sprintf( msg2 "Err: Lay MOS missing params: %s"
	       buildString( missingLay ",") )
	 ) ;when
	 when( !missingLay
	    sprintf( msg2 ""
	    )
	 ) ;when

	sprintf( msg "Err: %s ; %s" msg1 msg2 )
        return( msg )
      )

; now we know that w, l and m are defined for both plists

      if( (layPlist->m) then
	 layM = layPlist->m
	 else
	 if( (layPlist->M) then
	    layM = layPlist->M
	 else
	    layM = float(1)
	 )
      ) ; ** if layPlist **
      
      if( (layPlist->w) then
	 layW = float( layM * layPlist->w )
      else
	 if( (layPlist->W) then
	    layW = float( layM * layPlist->W )
	 )
      ) ; ** if layPlist **
      
      if( (layPlist->l) then
	 layL = float( layPlist->l )
      else
	 if( (layPlist->L) then
	    layL = float( layPlist->L )
	 )
      ) ; ** if layPlist **
      
      if( (schPlist->m) then
	 schM = schPlist->m
	 else
	 if( (schPlist->M) then
	    schM = schPlist->M
	 else
	    schM = float(1)
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->w) then
	 schW = float( schM * schPlist->w )
      else
	 if( (schPlist->W) then
	    schW = float( schM * schPlist->W )
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->l) then
	 schL = float( schPlist->l )
      else
	 if( (schPlist->L) then
	    schL = float( schPlist->L )
	 )
      ) ; ** if schPlist **

      diffW = 100 * (abs( layW - schW ) / schW )
      diffL = 100 * (abs( layL - schL ) / schL )
      diffM = 100 * (abs( layM - schM ) / schM )

      Werr = nil
      Lerr = nil
      Merr = nil

      when( diffW > mosW_lvsTol Werr = t
	 sprintf(msg
	    "Err: MOS Sch W %g; Lay W %g"
	    schW layW
	 )
      ) ; ** when diffW **
      when( diffL > mosL_lvsTol Lerr = t
	 sprintf(msg
	    "Err: MOS Sch L %g; Lay L %g"
	    schL layL
	 )
      ) ; ** when diffL **
      when( diffM > mosL_lvsTol Merr = t
	 sprintf(msg
	    "Err: MOS Sch M W %g %g; Lay M W %g %g"
	    float(schM) float(schW/schM) float(layM) float(layW/layM)
	 )
      ) ; ** when diffM **
      when( diffL > mosL_lvsTol Lerr = t && diffW > mosW_lvsTol Werr = t && diffM > 1.0 Merr = t
	 sprintf(
	    msg
	    "Err: MOS Sch L/W/M %g %g %g; Lay L/W/M %g %g %g"
	    float(schL) float(schW) float(schM) float(layL) float(layW) float(layM)
	 )
      ) ; ** when diffL **
      

; if no errors return nil

      when( !Werr && !Lerr && ! Merr return(nil) )

; now we know there is a parameter error

      ;;sprintf(
      ;;  msg
      ;;  "Err: MOS Sch L/W %g %g; Lay L/W %g %g"
      ;;  schL schW layL layW
      ;;)
          
      return( msg )

   ) ; end prog
  ) ; end compareMOS_m

; *****************************************************************
; Compare resistor properties

  procedure( compareRES( layPlist, schPlist )
    prog( (missingLay missingSch)

; If m (m factor) is missing, set it to 1

;;      when( !layPlist->m  layPlist->m = 1 )
;;      when( !schPlist->m  schPlist->m = 1 )

; If R is missing generate a parameter mismatch

      ;;foreach( prop '( r l w )
      foreach( prop '( l w )
        unless( get( layPlist prop )
	   unless( get( layPlist upperCase(prop) )
	      missingLay = cons( prop missingLay )
	   )
        ) ;unless
        unless( get( schPlist prop )
	   unless( get( schPlist upperCase(prop) )
	      missingSch = cons( prop missingSch )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missingLay || missingSch )

	 when( missingSch
	    sprintf( msg1 "Sch RES missing params: %s"
	       buildString( missingSch ",") )
	 ) ;when
	 when( !missingSch
	    sprintf( msg1 ""
	    )
	 ) ;when
	 
	 when( missingLay
	    sprintf( msg2 "Lay RES missing params: %s"
	       buildString( missingLay ",") )
	 ) ;when
	 when( !missingLay
	    sprintf( msg2 ""
	    )
	 ) ;when

	sprintf( msg "Err: %s ; %s" msg1 msg2 )
        return( msg )
      )

; now we know that r and m are defined for both plists
; correct for m here

      if( (layPlist->m) then
	 layM = float( layPlist->m )
	 else
	 if( (layPlist->M) then
	    layM = float( layPlist->M )
	 else
	    layM = float(1)
	 )
      ) ; ** if layPlist **
      
      if( (layPlist->w) then
	 layW = float( layPlist->w )
      else
	 if( (layPlist->W) then
	    layW = float( layPlist->W )
	 )
      ) ; ** if layPlist **
      
      if( (layPlist->l) then
	 ;;layL = float( layPlist->l / layM )
	 layL = float( layPlist->l )
      else
	 if( (layPlist->L) then
	    ;;layL = float( layPlist->L / layM )
	    layL = float( layPlist->L )
	 )
      ) ; ** if layPlist **

;      if( (layPlist->r) then
;	 layR = float( layPlist->r / layM )
;      else
;	 if( (layPlist->R) then
;	    layR = float( layPlist->R / layM )
;	 )
;      ) ; ** if layPlist **
      
      if( (schPlist->m) then
	 schM = float( schPlist->m )
	 else
	 if( (schPlist->M) then
	    schM = float( schPlist->M )
	 else
	    schM = float(1)
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->w) then
	 schW = float( schPlist->w )
      else
	 if( (schPlist->W) then
	    schW = float( schPlist->W )
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->l) then
	 ;;schL = float( schPlist->l / schM )
	 schL = float( schPlist->l )
      else
	 if( (schPlist->L) then
	    ;;schL = float( schPlist->L / schM )
	    schL = float( schPlist->L )
	 )
      ) ; ** if schPlist **

;      if( (schPlist->r) then
;	 schR = float( schPlist->r / schM )
;      else
;	 if( (schPlist->R) then
;	    schR = float( schPlist->R / schM )
;	 )
;      ) ; ** if schPlist **
      
      ;;diffR = 100 * (abs( layR - schR ) / schR )
      diffL = 100 * (abs( layL - schL ) / schL )
      diffW = 100 * (abs( layW - schW ) / schW )
      
      ;;Rerr = nil
      Lerr = nil
      Werr = nil

      ;;when( diffR > resR_lvsTol Rerr = t )
      when( diffL > resL_lvsTol Lerr = t )
      when( diffW > resW_lvsTol Werr = t )

      MultErr = nil
      when( schM > layM MultErr = t )
      when( schM < layM MultErr = t )
      

; if no errors return nil

      when( !Lerr && !Werr && !MultErr return(nil) )

; now we know there is a parameter error

      ;;sprintf( msg "Err: RES Sch R/L/W %g %g %g; Lay R/L/W %g %g %g"
      ;;  schR schL schW layR layL layW )
      sprintf( msg "Err: RES Sch L/W/M %g %g %g; Lay L/W/M %g %g %g"
        schL schW schM layL layW layM)
      return( msg )

   ) ; end prog
  ) ; end compareRES
  
; *****************************************************************
; Compare MOSCAP properties

  procedure( compareMOSCAP( layPlist, schPlist )
    prog( (missingLay missingSch)

; If m (m factor) is missing, set it to 1

;;      when( !layPlist->m  layPlist->m = 1 )
;;      when( !schPlist->m  schPlist->m = 1 )

; If W or L is missing generate a parameter mismatch

      foreach( prop '( w l )
        unless( get( layPlist prop )
	   unless( get( layPlist upperCase(prop) )
	      missingLay = cons( prop missingLay )
	   )
        ) ;unless
        unless( get( schPlist prop )
	   unless( get( schPlist upperCase(prop) )
	      missingSch = cons( prop missingSch )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missingLay || missingSch )

	 when( missingSch
	    sprintf( msg1 "Sch moscap missing params: %s"
	       buildString( missingSch ",") )
	 ) ;when
	 when( !missingSch
	    sprintf( msg1 ""
	    )
	 ) ;when

	 when( missingLay
	    sprintf( msg2 "Lay moscap missing params: %s"
	       buildString( missingLay ",") )
	 ) ;when
	 when( !missingLay
	    sprintf( msg2 ""
	    )
	 ) ;when

	sprintf( msg "Err: %s ; %s" msg1 msg2 )	 
        return( msg )
      )

; now we know that w, l and m are defined for both plists
; correct for m here

      if( (layPlist->m) then
	 layM = layPlist->m
	 else
	 if( (layPlist->M) then
	    layM = layPlist->M
	 else
	    layM = 1
	 )
      ) ; ** if layPlist **
      
      if( (layPlist->w) then
	 layW = float( layM * layPlist->w )
      else
	 if( (layPlist->W) then
	    layW = float( layM * layPlist->W )
	 )
      ) ; ** if layPlist **
      
      if( (layPlist->l) then
	 layL = float( layPlist->l )
      else
	 if( (layPlist->L) then
	    layL = float( layPlist->L )
	 )
      ) ; ** if layPlist **
      
      if( (schPlist->m) then
	 schM = schPlist->m
	 else
	 if( (schPlist->M) then
	    schM = schPlist->M
	 else
	    schM = 1
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->w) then
	 schW = float( schM * schPlist->w )
      else
	 if( (schPlist->W) then
	    schW = float( schM * schPlist->W )
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->l) then
	 schL = float( schPlist->l )
      else
	 if( (schPlist->L) then
	    schL = float( schPlist->L )
	 )
      ) ; ** if schPlist **

      diffW = 100 * (abs( layW - schW ) / schW )
      diffL = 100 * (abs( layL - schL ) / schL )

      Werr = nil
      Lerr = nil

      when( diffW > moscapW_lvsTol  Werr = t )
      when( diffL > moscapL_lvsTol  Lerr = t )

; if no errors return nil

      when( !Werr && !Lerr  return(nil) )

; now we know there is a parameter error

      sprintf(
        msg
        "Err: moscap Sch L/W %g %g; Lay L/W %g %g"
        schL schW layL layW
      )
      return( msg )

   ) ; end prog
  ) ; end compareMOSCAP


; *****************************************************************
; Compare MIMCAP properties

  procedure( compareMIMCAP( layPlist, schPlist )
    prog( (missingLay missingSch)

; If m (m factor) is missing, set it to 1

;;      when( !layPlist->m  layPlist->m = 1 )
;;      when( !schPlist->m  schPlist->m = 1 )
      
; If C is missing generate a parameter mismatch

      foreach( prop '( area )
        unless( get( layPlist prop )
	   unless( get( layPlist upperCase(prop) )
	      missingLay = cons( prop missingLay )
	   ) 
        ) ;unless
        unless( get( schPlist prop )
	   unless( get( schPlist upperCase(prop) )
	      missingSch = cons( prop missingSch )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missingLay || missingSch )

	 when( missingSch
	    sprintf( msg1 "Err: Sch mimcap missing params: %s"
	       buildString( missingSch ",") )
	 ) ;when
	 when( !missingSch
	    sprintf( msg1 ""
	    )
	 ) ;when

	 when( missingLay
	    sprintf( msg2 "Err: Lay mimcap missing params: %s"
	       buildString( missingLay ",") )
	 ) ;when
	 when( !missingLay
	    sprintf( msg2 ""
	    )
	 ) ;when

	sprintf( msg "Err: %s ; %s" msg1 msg2 )
        return( msg )
      )

; now we know that c and m are defined for both plists
; correct for m here

      Cvalue = t
      
       if( (layPlist->m) then
	  layM = float(layPlist->m)
	 else
	 if( (layPlist->M) then
	    layM = float(layPlist->M)
	 else
	    layM = float(1)
	 )
      ) ; ** if layPlist **
      
      if( (layPlist->area) then
	 layA = float( layPlist->area )
      else
	 if( (layPlist->AREA) then
	    layA = float( layPlist->AREA )
	 )
      ) ; ** if layPlist **
      
      if( (layPlist->c) then
	 layC = float( layPlist->c )
      else
	 if( (layPlist->C) then
	    layC = float( layPlist->C )
	 else
	    Cvalue = nil
	 )
      ) ; ** if layPlist **
      
      if( (schPlist->m) then
	 schM = float(schPlist->m)
	 else
	 if( (schPlist->M) then
	    schM = float(schPlist->M)
	 else
	    schM = float(1)
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->area) then
	 schA = float( schPlist->area )
      else
	 if( (schPlist->AREA) then
	    schA = float( schPlist->AREA )
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->c) then
	 schC = float( schPlist->c )
      else
	 if( (schPlist->C) then
	    schC = float( schPlist->C )
	 else
	    Cvalue = nil
	 )
      ) ; ** if schPlist **

      diffA = 100 * (abs( layA - schA ) / schA )

      Aerr = nil

      when( diffA > mimcapA_lvsTol  Aerr = t )

      MultErr = nil
      when( schM > layM MultErr = t )
      when( schM < layM MultErr = t )

; if no errors return nil

      when( !Aerr && !MultErr return(nil) )

; now we know there is a parameter error

      when( !Cvalue
	 sprintf(
	    msg
	    "Err: mimcap Sch AREA %g M %g; Lay AREA %g M %g" schA schM layA layM
	 )
      ) ; ** when Cvalue **
      when( Cvalue
	 sprintf(
	    msg
	    "Err: mimcap Sch AREA %g C %g M %g; Lay AREA %g C %g M %g" schA schC schM layA layC layM
	 )
      ) ; ** when Cvalue **
      return( msg )

   ) ; end prog
  ) ; end compareMIMCAP


; *****************************************************************
; Compare CAP properties

  procedure( compareCAP( layPlist, schPlist )
    prog( (missingLay missingSch)

; If m (m factor) is missing, set it to 1

;;      when( !layPlist->m  layPlist->m = 1 )
;;      when( !schPlist->m  schPlist->m = 1 )
      
; If C is missing generate a parameter mismatch

      foreach( prop '( area perimeter )
        unless( get( layPlist prop )
	   unless( get( layPlist upperCase(prop) )
	      missingLay = cons( prop missingLay )
	   ) 
        ) ;unless
        unless( get( schPlist prop )
	   unless( get( schPlist upperCase(prop) )
	      missingSch = cons( prop missingSch )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missingLay || missingSch )

	 when( missingSch
	    sprintf( msg1 "Err: Sch cap missing params: %s"
	       buildString( missingSch ",") )
	 ) ;when
	 when( !missingSch
	    sprintf( msg1 ""
	    )
	 ) ;when

	 when( missingLay
	    sprintf( msg2 "Err: Lay cap missing params: %s"
	       buildString( missingLay ",") )
	 ) ;when
	 when( !missingLay
	    sprintf( msg2 ""
	    )
	 ) ;when

	sprintf( msg "Err: %s ; %s" msg1 msg2 )
        return( msg )
      )

; now we know that c and m are defined for both plists
; correct for m here

      Cvalue = t
      
       if( (layPlist->m) then
	  layM = float(layPlist->m)
	 else
	 if( (layPlist->M) then
	    layM = float(layPlist->M)
	 else
	    layM = float(1)
	 )
      ) ; ** if layPlist **
      
      if( (layPlist->area) then
	 layA = float( layPlist->area )
      else
	 if( (layPlist->AREA) then
	    layA = float( layPlist->AREA )
	 )
      ) ; ** if layPlist **

     if( (layPlist->perimeter) then
	 layP = float( layPlist->perimeter )
      else
	 if( (layPlist->PERIMETER) then
	    layP = float( layPlist->PERIMETER )
	 )
      ) ; ** if layPlist ** 
      
      if( (layPlist->c) then
	 layC = float( layPlist->c )
      else
	 if( (layPlist->C) then
	    layC = float( layPlist->C )
	 else
	    Cvalue = nil
	 )
      ) ; ** if layPlist **
      
      if( (schPlist->m) then
	 schM = float(schPlist->m)
	 else
	 if( (schPlist->M) then
	    schM = float(schPlist->M)
	 else
	    schM = float(1)
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->area) then
	 schA = float( schPlist->area )
      else
	 if( (schPlist->AREA) then
	    schA = float( schPlist->AREA )
	 )
      ) ; ** if schPlist **

      if( (schPlist->perimeter) then
	 schP = float( schPlist->perimeter )
      else
	 if( (schPlist->PERIMETER) then
	    schP = float( schPlist->PERIMETER )
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->c) then
	 schC = float( schPlist->c )
      else
	 if( (schPlist->C) then
	    schC = float( schPlist->C )
	 else
	    Cvalue = nil
	 )
      ) ; ** if schPlist **

      diffA = 100 * (abs( layA - schA ) / schA )
      diffP = 100 * (abs( layP - schP ) / schP )

      Aerr = nil

      when( diffA > mimcapA_lvsTol  Aerr = t )
      when( diffP > mimcapA_lvsTol  Aerr = t )

      MultErr = nil
      when( schM > layM MultErr = t )
      when( schM < layM MultErr = t )

; if no errors return nil

      when( !Aerr && !MultErr return(nil) )

; now we know there is a parameter error

      when( !Cvalue
	 sprintf(
	    msg
	    "Err: cap Sch AREA %g PERIMETER %g M %g; Lay AREA %g PERIMETER %g M %g" schA schP schM layA layP layM
	 )
      ) ; ** when Cvalue **
      when( Cvalue
	 sprintf(
	    msg
	    "Err: cap Sch AREA %g PERIMETER %g C %g M %g; Lay AREA %g PERIMETER %g C %g M %g" schA schP schC schM layA layP layC layM
	 )
      ) ; ** when Cvalue **
      return( msg )

   ) ; end prog
  ) ; end compareCAP

  
; *****************************************************************
; Compare BJT device properties

  procedure( compareBJT( layPlist, schPlist )
    ;;prog( (missingLay missingSch)
    prog( ()

; If m is missing, set it to 1

;;      when( !layPlist->m  layPlist->m = 1 )
;;      when( !schPlist->m  schPlist->m = 1 )

; If area is missing generate a parameter mismatch
/*
      foreach( prop '( area )
        unless( get( layPlist prop )
	   unless( get( layPlist upperCase(prop) )
	      missingLay = cons( prop missingLay )
	   )
        ) ;unless
        unless( get( schPlist prop )
	   unless( get( schPlist upperCase(prop) )
	      missingSch = cons( prop missingSch )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missingLay || missingSch )

	 when( missingSch
	    sprintf( msg1 "Sch BJT missing params: %s"
	       buildString( missingSch ",") )
	 ) ;when
	 when( !missingSch
	    sprintf( msg1 ""
	    )
	 ) ;when

	 when( missingLay
	    sprintf( msg2 "Lay BJT missing params: %s"
	       buildString( missingLay ",") )
	 ) ;when
	 when( !missingLay
	    sprintf( msg2 ""
	    )
	 ) ;when

	sprintf( msg "Err: %s ; %s" msg1 msg2 )        
        return( msg )
      )
*/
; now we know that area and m are defined for both plists
; correct for m here

      if( (layPlist->m) then
	 layM = float(layPlist->m)
	 else
	 if( (layPlist->M) then
	    layM = float(layPlist->M)
	 else
	    layM = float(1)
	 )
      ) ; ** if layPlist **
/*      
      if( (layPlist->area) then
	 layA = float( layPlist->area )
      else
	 if( (layPlist->AREA) then
	    layA = float( layPlist->AREA )
	 )
      ) ; ** if layPlist **
*/      
      if( (schPlist->m) then
	 schM = float(schPlist->m)
	 else
	 if( (schPlist->M) then
	    schM = float(schPlist->M)
	 else
	    schM = float(1)
	 )
      ) ; ** if schPlist **
/*      
      if( (schPlist->area) then
	 schA = float( schPlist->area )
      else
	 if( (schPlist->AREA) then
	    schA = float( schPlist->AREA )
	 )
      ) ; ** if schPlist **
*/
      ;;diffA = 100 * (abs( layA - schA ) / schA )

      ;;areaErr = nil

      ;;when( diffA > bjtAREA_lvsTol areaErr = t )

      MultErr = nil
      when( schM > layM MultErr = t )
      when( schM < layM MultErr = t )

; if no errors return nil

      ;;when( !areaErr && !MultErr return(nil) )
      when( !MultErr return(nil) )

; now we know there is a parameter error

      ;;sprintf( msg "Err: BJT Sch Area %g M %g; Lay Area %g M %g"
        ;;schA schM layA layM )
      sprintf( msg "Err: BJT Sch M %g; Lay M %g"
        schM layM )
      return( msg )

   ) ; end prog
  ) ; end compareBJT

; *****************************************************************
; Compare BJT (Length parameter) device properties

  procedure( compareBJT_l( layPlist, schPlist )
    prog( (missingLay missingSch)

; If m is missing, set it to 1

;;      when( !layPlist->m  layPlist->m = 1 )
;;      when( !schPlist->m  schPlist->m = 1 )

; If area is missing generate a parameter mismatch

      foreach( prop '( le )
        unless( get( layPlist prop )
	   unless( get( layPlist upperCase(prop) )
	      missingLay = cons( prop missingLay )
	   )
        ) ;unless
        unless( get( schPlist prop )
	   unless( get( schPlist upperCase(prop) )
	      missingSch = cons( prop missingSch )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missingLay || missingSch )

	 when( missingSch
	    sprintf( msg1 "Sch BJT missing params: %s"
	       buildString( missingSch ",") )
	 ) ;when
	 when( !missingSch
	    sprintf( msg1 ""
	    )
	 ) ;when

	 when( missingLay
	    sprintf( msg2 "Lay BJT missing params: %s"
	       buildString( missingLay ",") )
	 ) ;when
	 when( !missingLay
	    sprintf( msg2 ""
	    )
	 ) ;when

	sprintf( msg "Err: %s ; %s" msg1 msg2 )        
        return( msg )
      )

; now we know that Emitter Length and m are defined for both plists
; correct for m here

      if( (layPlist->m) then
	 layM = float(layPlist->m)
	 else
	 if( (layPlist->M) then
	    layM = float(layPlist->M)
	 else
	    layM = float(1)
	 )
      ) ; ** if layPlist **
      
      if( (layPlist->le) then
	 layA = float( layPlist->le )
      else
	 if( (layPlist->LE) then
	    layA = float( layPlist->LE )
	 )
      ) ; ** if layPlist **
      
      if( (schPlist->m) then
	 schM = float(schPlist->m)
	 else
	 if( (schPlist->M) then
	    schM = float(schPlist->M)
	 else
	    schM = float(1)
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->le) then
	 schA = float( schPlist->le )
      else
	 if( (schPlist->LE) then
	    schA = float( schPlist->LE )
	 )
      ) ; ** if schPlist **

      diffA = 100 * (abs( layA - schA ) / schA )

      leErr = nil

      when( diffA > bjtLE_lvsTol leErr = t )

      MultErr = nil
      when( schM > layM MultErr = t )
      when( schM < layM MultErr = t )

; if no errors return nil

      when( !leErr && !MultErr return(nil) )

; now we know there is a parameter error

      sprintf( msg "Err: BJT Sch Emitter Length %g M %g; Lay Emitter Length %g M %g"
        schA schM layA layM )
      return( msg )

   ) ; end prog
  ) ; end compareBJT_l

; *****************************************************************  
; Compare diode properties

  procedure( compareDIO( layPlist, schPlist )
    prog( (missingLay missingSch)

; If m is missing, set it to 1

;;      when( !layPlist->m  layPlist->m = 1 )
;;      when( !schPlist->m  schPlist->m = 1 )

; If "area" is missing generate a parameter mismatch

      foreach( prop '( area pj )
        unless( get( layPlist prop )
	   unless( get( layPlist upperCase(prop) )
	      missingLay = cons( prop missingLay )
	   )
        ) ;unless
        unless( get( schPlist prop )
	   unless( get( schPlist upperCase(prop) )
          missingSch = cons( prop missingSch )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missingLay || missingSch )

	 when( missingSch
	    sprintf( msg1 "Sch DIODE missing params: %s"
	       buildString( missingSch ",") )
	 ) ;when
	 when( !missingSch
	    sprintf( msg1 ""
	    )
	 ) ;when

	 when( missingLay
	    sprintf( msg2 "Lay DIODE missing params: %s"
	       buildString( missingLay ",") )
	 ) ;when
	 when( !missingLay
	    sprintf( msg2 ""
	    )
	 ) ;when

	sprintf( msg "Err: %s ; %s" msg1 msg2 )
        return( msg )
      )

; now we know that area and m are defined for both plists
; correct for m here

      if( (layPlist->m) then
	 layM = layPlist->m
	 else
	 if( (layPlist->M) then
	    layM = layPlist->M
	 else
	    layM = 1
	 )
      ) ; ** if layPlist **
      
      if( (layPlist->area) then
	 layA = float( layM * layPlist->area )
      else
	 if( (layPlist->AREA) then
	    layA = float( layM * layPlist->AREA )
	 )
      ) ; ** if layPlist **

      if( (layPlist->pj) then
	 layP = float( layM * layPlist->pj )
      else
	 if( (layPlist->PJ) then
	    layP = float( layM * layPlist->PJ )
	 )
      ) ; ** if layPlist **
      
      if( (schPlist->m) then
	 schM = schPlist->m
	 else
	 if( (schPlist->M) then
	    schM = schPlist->M
	 else
	    schM = 1
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->area) then
	 schA = float( schM * schPlist->area )
      else
	 if( (schPlist->AREA) then
	    schA = float( schM * schPlist->AREA )
	 )
      ) ; ** if schPlist **

      if( (schPlist->pj) then
	 schP = float( schM * schPlist->pj )
      else
	 if( (schPlist->PJ) then
	    schP = float( schM * schPlist->PJ )
	 )
      ) ; ** if schPlist **

      diffA = 100 * (abs( layA - schA ) / schA )
      ;;diffP = 100 * (abs( layP - schP ) / schP )

      areaErr = nil
      perimErr = nil

      when( diffA > diodeAREA_lvsTol areaErr = t )
      ;;when( diffP > diodePERIM_lvsTol perimErr = t )
      when( (abs(layP-schP) > 0.05*schP) perimErr = t )

; if no errors return nil

      when( !areaErr && !perimErr return(nil) )

; now we know there is a parameter error

      sprintf( msg "Err: DIODE Sch Area %g Perim %g; Lay Area %g Perim %g" schA schP layA layP)
      return( msg )

   ) ; end prog
  ) ; end compareDIO

; *****************************************************************  
; Compare diode properties

  procedure( compareDPHO( layPlist, schPlist )
    prog( (missingLay missingSch)

; If m is missing, set it to 1

;;      when( !layPlist->m  layPlist->m = 1 )
;;      when( !schPlist->m  schPlist->m = 1 )

; If "area" is missing generate a parameter mismatch

      foreach( prop '( area perimeter )
        unless( get( layPlist prop )
	   unless( get( layPlist upperCase(prop) )
	      missingLay = cons( prop missingLay )
	   )
        ) ;unless
        unless( get( schPlist prop )
	   unless( get( schPlist upperCase(prop) )
          missingSch = cons( prop missingSch )
	   )
        ) ;unless
      ) ;foreach

; Report all missing parameters

      when( ( missingLay || missingSch )

	 when( missingSch
	    sprintf( msg1 "Sch DIODE missing params: %s"
	       buildString( missingSch ",") )
	 ) ;when
	 when( !missingSch
	    sprintf( msg1 ""
	    )
	 ) ;when

	 when( missingLay
	    sprintf( msg2 "Lay DIODE missing params: %s"
	       buildString( missingLay ",") )
	 ) ;when
	 when( !missingLay
	    sprintf( msg2 ""
	    )
	 ) ;when

	sprintf( msg "Err: %s ; %s" msg1 msg2 )
        return( msg )
      )

; now we know that area and m are defined for both plists
; correct for m here

      if( (layPlist->m) then
	 layM = layPlist->m
	 else
	 if( (layPlist->M) then
	    layM = layPlist->M
	 else
	    layM = 1
	 )
      ) ; ** if layPlist **
      
      if( (layPlist->area) then
	 layA = float( layM * layPlist->area )
      else
	 if( (layPlist->AREA) then
	    layA = float( layM * layPlist->AREA )
	 )
      ) ; ** if layPlist **

      if( (layPlist->perimeter) then
	 layP = float( layM * layPlist->perimeter )
      else
	 if( (layPlist->PERIMETER) then
	    layP = float( layM * layPlist->PERIMETER )
	 )
      ) ; ** if layPlist **
      
      if( (schPlist->m) then
	 schM = schPlist->m
	 else
	 if( (schPlist->M) then
	    schM = schPlist->M
	 else
	    schM = 1
	 )
      ) ; ** if schPlist **
      
      if( (schPlist->area) then
	 schA = float( schM * schPlist->area )
      else
	 if( (schPlist->AREA) then
	    schA = float( schM * schPlist->AREA )
	 )
      ) ; ** if schPlist **

      if( (schPlist->perimeter) then
	 schP = float( schM * schPlist->perimeter )
      else
	 if( (schPlist->PERIMETER) then
	    schP = float( schM * schPlist->PERIMETER )
	 )
      ) ; ** if schPlist **

      diffA = 100 * (abs( layA - schA ) / schA )
      diffP = 100 * (abs( layP - schP ) / schP )

      areaErr = nil
      perimErr = nil

      when( diffA > dphoAREA_lvsTol areaErr = t )
      when( diffP > dphoPERIM_lvsTol perimErr = t )

; if no errors return nil

      when( !areaErr && !perimErr return(nil) )

; now we know there is a parameter error

      sprintf( msg "Err: DIODE Sch Area %g Perim %g; Lay Area %g Perim %g" schA schP layA layP)
      return( msg )

   ) ; end prog
  ) ; end compareDPHO

  procedure( doNotCompareRes(arg1 arg2) prog( () return(nil) ) )
  
; *********************************************************************
; Call the procedures
; *********************************************************************

; Device combining
  ;;mergeParallel( CAP noMerge )
  ;;mergeParallel( "cmm" merge parallelMIMCAP )
  ;;mergeParallel( "cdmm" merge parallelMIMCAP )
  ;;mergeParallel( "ctmm" merge parallelMIMCAP )
  mergeParallel( "cmm3" merge parallelMIMCAP )
  mergeParallel( "cmm3t" merge parallelMIMCAP )
  mergeParallel( "cmm4" merge parallelMIMCAP )
  mergeParallel( "cmm4t" merge parallelMIMCAP )
  mergeParallel( "cmm5t" merge parallelMIMCAP )
  mergeParallel( "cmm6t" merge parallelMIMCAP )
  mergeParallel( "cmmh3" merge parallelMIMCAP )
  mergeParallel( "cmmh3t" merge parallelMIMCAP )
  mergeParallel( "cmmh4" merge parallelMIMCAP )
  mergeParallel( "cmmh4t" merge parallelMIMCAP )
  mergeParallel( "cmmh5t" merge parallelMIMCAP )
  mergeParallel( "cmmh6t" merge parallelMIMCAP )
  mergeParallel( "cdmm4" merge parallelMIMCAP )
  mergeParallel( "cdmm4t" merge parallelMIMCAP )
  mergeParallel( "ctmm5" merge parallelMIMCAP )
  mergeParallel( "ctmm5t" merge parallelMIMCAP )
  mergeParallel( "cdmmh4" merge parallelMIMCAP )
  mergeParallel( "cdmmh4t" merge parallelMIMCAP )
  mergeParallel( "ctmmh5" merge parallelMIMCAP )
  mergeParallel( "ctmmh5t" merge parallelMIMCAP )
  ;;mergeParallel( "CMM" merge parallelMIMCAP )
  ;;mergeParallel( "CDMM" merge parallelMIMCAP )
  ;;mergeParallel( "CTMM" merge parallelMIMCAP )
  mergeParallel( "CMM3" merge parallelMIMCAP )
  mergeParallel( "CMM3T" merge parallelMIMCAP )
  mergeParallel( "CMM4" merge parallelMIMCAP )
  mergeParallel( "CMM4T" merge parallelMIMCAP )
  mergeParallel( "CMM5T" merge parallelMIMCAP )
  mergeParallel( "CMM6T" merge parallelMIMCAP )
  mergeParallel( "CMMH3" merge parallelMIMCAP )
  mergeParallel( "CMMH3T" merge parallelMIMCAP )
  mergeParallel( "CMMH4" merge parallelMIMCAP )
  mergeParallel( "CMMH4T" merge parallelMIMCAP )
  mergeParallel( "CMMH5T" merge parallelMIMCAP )
  mergeParallel( "CMMH6T" merge parallelMIMCAP )
  mergeParallel( "CDMM4" merge parallelMIMCAP )
  mergeParallel( "CDMM4T" merge parallelMIMCAP )
  mergeParallel( "CTMM5" merge parallelMIMCAP )
  mergeParallel( "CTMM5T" merge parallelMIMCAP )
  mergeParallel( "CDMMH4" merge parallelMIMCAP )
  mergeParallel( "CDMMH4T" merge parallelMIMCAP )
  mergeParallel( "CTMMH5" merge parallelMIMCAP )
  mergeParallel( "CTMMH5T" merge parallelMIMCAP )

  mergeParallel( "csandwt3" merge parallelCAP )
  mergeParallel( "csandwt4" merge parallelCAP )
  mergeParallel( "csandwt5" merge parallelCAP )
  mergeParallel( "CSANDWT3" merge parallelCAP )
  mergeParallel( "CSANDWT4" merge parallelCAP )
  mergeParallel( "CSANDWT5" merge parallelCAP )

  mergeParallel( "csf2p" merge parallelCAP )
  mergeParallel( "CSF2P" merge parallelCAP )
  mergeParallel( "csf3p" merge parallelCAP )
  mergeParallel( "CSF3P" merge parallelCAP )
  mergeParallel( "csf3" merge parallelCAP )
  mergeParallel( "CSF3" merge parallelCAP )
  mergeParallel( "csf4" merge parallelCAP )
  mergeParallel( "CSF4" merge parallelCAP )
  mergeParallel( "csft4" merge parallelCAP )
  mergeParallel( "CSFT4" merge parallelCAP )
  mergeParallel( "csf5" merge parallelCAP )
  mergeParallel( "CSF5" merge parallelCAP )
  mergeParallel( "csft5" merge parallelCAP )
  mergeParallel( "CSFT5" merge parallelCAP )
  mergeParallel( "csft6" merge parallelCAP )
  mergeParallel( "CSFT6" merge parallelCAP )

  mergeParallel( "csf3a" merge parallelCAP )
  mergeParallel( "CSF3A" merge parallelCAP )
  mergeParallel( "csf4a" merge parallelCAP )
  mergeParallel( "CSF4A" merge parallelCAP )
  mergeParallel( "csft4a" merge parallelCAP )
  mergeParallel( "CSFT4A" merge parallelCAP )
  mergeParallel( "csf5a" merge parallelCAP )
  mergeParallel( "CSF5A" merge parallelCAP )
  mergeParallel( "csft5a" merge parallelCAP )
  mergeParallel( "CSFT5A" merge parallelCAP )
  mergeParallel( "csft6a" merge parallelCAP )
  mergeParallel( "CSFT6A" merge parallelCAP )

  mergeParallel( "cpod" merge parallelCAP )
  mergeParallel( "cpod3" merge parallelCAP )
  mergeParallel( "cpodhv" merge parallelCAP )
  mergeParallel( "CPOD" merge parallelCAP )
  mergeParallel( "CPOD3" merge parallelCAP )
  mergeParallel( "CPODHV" merge parallelCAP )

  mergeParallel( MOS merge parallelMOS )
  mergeParallel( "nmma" merge parallelMOS )
  mergeParallel( "pmma" merge parallelMOS )
  mergeParallel( "NMMA" merge parallelMOS )
  mergeParallel( "PMMA" merge parallelMOS )
  mergeParallel( "nmmc" merge parallelMOS )
  mergeParallel( "nmmd" merge parallelMOS )
  mergeParallel( "pmmc" merge parallelMOS )
  mergeParallel( "NMMC" merge parallelMOS )
  mergeParallel( "NMMD" merge parallelMOS )
  mergeParallel( "PMMC" merge parallelMOS )
  mergeParallel( "nma" merge parallelMOS )
  mergeParallel( "pma" merge parallelMOS )
  mergeParallel( "NMA" merge parallelMOS )
  mergeParallel( "PMA" merge parallelMOS )
  mergeParallel( "nmc" merge parallelMOS )
  mergeParallel( "pmc" merge parallelMOS )
  mergeParallel( "NMC" merge parallelMOS )
  mergeParallel( "PMC" merge parallelMOS )
  mergeParallel( "nhhv" merge parallelMOS )
  mergeParallel( "phhv" merge parallelMOS )
  mergeParallel( "NHHV" merge parallelMOS )
  mergeParallel( "PHHV" merge parallelMOS )
  mergeParallel( "nhv" merge parallelMOS )
  mergeParallel( "phv" merge parallelMOS )
  mergeParallel( "NHV" merge parallelMOS )
  mergeParallel( "PHV" merge parallelMOS )
  mergeParallel( "nedi" merge parallelMOS )
  mergeParallel( "nedia" merge parallelMOS )
  mergeParallel( "ped2" merge parallelMOS )
  mergeParallel( "ped" merge parallelMOS )
  mergeParallel( "NEDI" merge parallelMOS )
  mergeParallel( "NEDIA" merge parallelMOS )
  mergeParallel( "PED2" merge parallelMOS )
  mergeParallel( "PED" merge parallelMOS )

  mergeParallel( "nhhvd" merge parallelMOS )
  mergeParallel( "NHHVD" merge parallelMOS )
  mergeParallel( "nhvd" merge parallelMOS )
  mergeParallel( "NHVD" merge parallelMOS )

  mergeParallel( "nhhvd_bjt" merge parallelMOS )
  mergeParallel( "NHHVD_BJT" merge parallelMOS )
  mergeParallel( "nhvd_bjt" merge parallelMOS )
  mergeParallel( "NHVD_BJT" merge parallelMOS )

  mergeParallel( "nmma_bjt" merge parallelMOS )
  mergeParallel( "nmmc_bjt" merge parallelMOS )
  mergeParallel( "nmmd_bjt" merge parallelMOS )
  mergeParallel( "nma_bjt" merge parallelMOS )
  mergeParallel( "nmc_bjt" merge parallelMOS )
  mergeParallel( "nhhv_bjt" merge parallelMOS )
  mergeParallel( "nhv_bjt" merge parallelMOS )
  mergeParallel( "NMMA_BJT" merge parallelMOS )
  mergeParallel( "NMMC_BJT" merge parallelMOS )
  mergeParallel( "NMMD_BJT" merge parallelMOS )
  mergeParallel( "NMA_BJT" merge parallelMOS )
  mergeParallel( "NMC_BJT" merge parallelMOS )
  mergeParallel( "NHHV_BJT" merge parallelMOS )
  mergeParallel( "NHV_BJT" merge parallelMOS )

  mergeParallel( "nedi_bjt" merge parallelMOS )
  mergeParallel( "nedia_bjt" merge parallelMOS )
  mergeParallel( "ped2_bjt" merge parallelMOS )
  mergeParallel( "ped_bjt" merge parallelMOS )
  mergeParallel( "NEDI_BJT" merge parallelMOS )
  mergeParallel( "NEDIA_BJT" merge parallelMOS )
  mergeParallel( "PED2_BJT" merge parallelMOS )
  mergeParallel( "PED_BJT" merge parallelMOS )

  mergeParallel( "pma_bjt" merge parallelMOS )
  mergeParallel( "PMA_BJT" merge parallelMOS )
  mergeParallel( "pmc_bjt" merge parallelMOS )
  mergeParallel( "PMC_BJT" merge parallelMOS )
  mergeParallel( "pmma_bjt" merge parallelMOS )
  mergeParallel( "PMMA_BJT" merge parallelMOS )
  mergeParallel( "pmmc_bjt" merge parallelMOS )
  mergeParallel( "PMMC_BJT" merge parallelMOS )
  mergeParallel( "phv_bjt" merge parallelMOS )
  mergeParallel( "PHV_BJT" merge parallelMOS )
  mergeParallel( "phhv_bjt" merge parallelMOS )
  mergeParallel( "PHHV_BJT" merge parallelMOS )

  mergeParallel( "pedam" merge parallelMOS )
  mergeParallel( "PEDAM" merge parallelMOS )
  mergeParallel( "nedam" merge parallelMOS )
  mergeParallel( "NEDAM" merge parallelMOS )
  mergeParallel( "pedam_bjt" merge parallelMOS )
  mergeParallel( "PEDAM_BJT" merge parallelMOS )
  mergeParallel( "nedam_bjt" merge parallelMOS )
  mergeParallel( "NEDAM_BJT" merge parallelMOS )

  mergeParallel( "mosvc" merge parallelMOS )
  mergeParallel( "mosvc3" merge parallelMOS )
  mergeParallel( "mosvci" merge parallelMOS )
  mergeParallel( "mosvci_m" merge parallelMOS )
  mergeParallel( "mosvc3i" merge parallelMOS )
  mergeParallel( "mosvc3i_m" merge parallelMOS )
  mergeParallel( "MOSVC" merge parallelMOS )
  mergeParallel( "MOSVC3" merge parallelMOS )
  mergeParallel( "MOSVCI" merge parallelMOS )
  mergeParallel( "MOSVCI_M" merge parallelMOS )
  mergeParallel( "MOSVC3I" merge parallelMOS )
  mergeParallel( "MOSVC3I_M" merge parallelMOS )
  
  ;;mergeParallel( "ndsi" noMerge )
  mergeParallel( "nds3i" noMerge )
  ;;mergeParallel( "NDSI" noMerge )
  mergeParallel( "NDS3I" noMerge )

  mergeParallel( "nha3m" merge parallelMOS )
  mergeParallel( "NHA3M" merge parallelMOS )
  mergeParallel( "cnn_otpa" noMerge )
  mergeParallel( "CNN_OTPA" noMerge )
  
  ;;mergeParallel( RES noMerge )
  mergeParallel( RES merge parallelRES )
  mergeParallel( "s_res" noMerge )
  mergeParallel( "rnw_scr" noMerge )
  mergeParallel( "rnw3_scr" noMerge )
  mergeParallel( "rdp_io" noMerge )
  mergeParallel( "S_RES" noMerge )
  mergeParallel( "RNW_SCR" noMerge )
  mergeParallel( "RNW3_SCR" noMerge )
  mergeParallel( "RDP_IO" noMerge )
  
  ;;mergeParallel( BJT  merge parallelBJT )
  ;;mergeParallel( BJT noMerge )
  mergeParallel( "qnva"  merge parallelBJT_l )
  mergeParallel( "qnvb"  merge parallelBJT_l )
  mergeParallel( "qnvc"  merge parallelBJT_l )
  mergeParallel( "qnvz"  merge parallelBJT_l )
  mergeParallel( "qpva"  merge parallelBJT )
  mergeParallel( "qpvb"  merge parallelBJT )
  mergeParallel( "qpvc"  merge parallelBJT )
  mergeParallel( "qpva3"  merge parallelBJT )
  mergeParallel( "qpvb3"  merge parallelBJT )
  mergeParallel( "qpvc3"  merge parallelBJT )
  mergeParallel( "QNVA"  merge parallelBJT_l )
  mergeParallel( "QNVB"  merge parallelBJT_l )
  mergeParallel( "QNVC"  merge parallelBJT_l )
  mergeParallel( "QNVZ"  merge parallelBJT_l )
  mergeParallel( "QPVA"  merge parallelBJT )
  mergeParallel( "QPVB"  merge parallelBJT )
  mergeParallel( "QPVC"  merge parallelBJT )
  mergeParallel( "QPVA3"  merge parallelBJT )
  mergeParallel( "QPVB3"  merge parallelBJT )
  mergeParallel( "QPVC3"  merge parallelBJT )
  mergeParallel( "qpvhscr"  merge parallelBJT_l )
  mergeParallel( "QPVHSCR"  merge parallelBJT_l )
  mergeParallel( "qpvascr"  merge parallelBJT_l )
  mergeParallel( "QPVASCR"  merge parallelBJT_l )
  mergeParallel( "qpvhbscr"  merge parallelBJT_l )
  mergeParallel( "QPVHBSCR"  merge parallelBJT_l )

  mergeParallel( "qnvam"  merge parallelBJT )
  mergeParallel( "QNVAM"  merge parallelBJT )

  mergeParallel( DIO merge parallelDIO )

  mergeParallel( "dphoc" noMerge )
  mergeParallel( "DPHOC" noMerge )
  mergeParallel( "dphoc0" noMerge )
  mergeParallel( "DPHOC0" noMerge )
  mergeParallel( "dphocfp" noMerge )
  mergeParallel( "DPHOCFP" noMerge )
  mergeParallel( "dphod" noMerge )
  mergeParallel( "DPHOD" noMerge )
  mergeParallel( "dphod0" noMerge )
  mergeParallel( "DPHOD0" noMerge )
  mergeParallel( "dphodfp" noMerge )
  mergeParallel( "DPHODFP" noMerge )

  mergeParallel( "dapda" noMerge )
  mergeParallel( "dapda0" noMerge )
  mergeParallel( "DAPDA" noMerge )
  mergeParallel( "DAPDA0" noMerge )
  mergeParallel( "dspada" noMerge )
  mergeParallel( "dspada0" noMerge )
  mergeParallel( "DSPADA" noMerge )
  mergeParallel( "DSPADA0" noMerge )

  mergeSeries( CAP noMerge )
  
  mergeSeries( MOS noMerge )
  mergeSeries( "nmma" noMerge )
  mergeSeries( "pmma" noMerge )
  mergeSeries( "nmmc" noMerge )
  mergeSeries( "nmmd" noMerge )
  mergeSeries( "pmmc" noMerge )
  mergeSeries( "nma" noMerge )
  mergeSeries( "pma" noMerge )
  mergeSeries( "nmc" noMerge )
  mergeSeries( "pmc" noMerge )
  mergeSeries( "nhhv" noMerge )
  mergeSeries( "phhv" noMerge )
  mergeSeries( "nhv" noMerge )
  mergeSeries( "phv" noMerge )
  mergeSeries( "nedi" noMerge )
  mergeSeries( "nedia" noMerge )
  mergeSeries( "ped2" noMerge )
  mergeSeries( "ped" noMerge )
  mergeSeries( "NMMA" noMerge )
  mergeSeries( "PMMA" noMerge )
  mergeSeries( "NMMC" noMerge )
  mergeSeries( "NMMD" noMerge )
  mergeSeries( "PMMC" noMerge )
  mergeSeries( "NMA" noMerge )
  mergeSeries( "PMA" noMerge )
  mergeSeries( "NMC" noMerge )
  mergeSeries( "PMC" noMerge )
  mergeSeries( "NHHV" noMerge )
  mergeSeries( "PHHV" noMerge )
  mergeSeries( "NHV" noMerge )
  mergeSeries( "PHV" noMerge )
  mergeSeries( "NEDI" noMerge )
  mergeSeries( "NEDIA" noMerge )
  mergeSeries( "PED2" noMerge )
  mergeSeries( "PED" noMerge )

  mergeSeries( "nhhvd" noMerge )
  mergeSeries( "NHHVD" noMerge )
  mergeSeries( "nhvd" noMerge )
  mergeSeries( "NHVD" noMerge )

  mergeSeries( "nhhvd_bjt" noMerge )
  mergeSeries( "NHHVD_BJT" noMerge )
  mergeSeries( "nhvd_bjt" noMerge )
  mergeSeries( "NHVD_BJT" noMerge )

  mergeSeries( "nmma_bjt" noMerge )
  mergeSeries( "nmmc_bjt" noMerge )
  mergeSeries( "nmmd_bjt" noMerge )
  mergeSeries( "nma_bjt" noMerge )
  mergeSeries( "nmc_bjt" noMerge )
  mergeSeries( "nhhv_bjt" noMerge )
  mergeSeries( "nhv_bjt" noMerge )
  mergeSeries( "NMMA_BJT" noMerge )
  mergeSeries( "NMMC_BJT" noMerge )
  mergeSeries( "NMMD_BJT" noMerge )
  mergeSeries( "NMA_BJT" noMerge )
  mergeSeries( "NMC_BJT" noMerge )
  mergeSeries( "NHHV_BJT" noMerge )
  mergeSeries( "NHV_BJT" noMerge )

  mergeSeries( "nedi_bjt" noMerge )
  mergeSeries( "nedia_bjt" noMerge )
  mergeSeries( "ped2_bjt" noMerge )
  mergeSeries( "ped_bjt" noMerge )
  mergeSeries( "NEDI_BJT" noMerge )
  mergeSeries( "NEDIA_BJT" noMerge )
  mergeSeries( "PED2_BJT" noMerge )
  mergeSeries( "PED_BJT" noMerge )
  
  mergeSeries( "pma_bjt" noMerge )
  mergeSeries( "PMA_BJT" noMerge )
  mergeSeries( "pmc_bjt" noMerge )
  mergeSeries( "PMC_BJT" noMerge )
  mergeSeries( "pmma_bjt" noMerge )
  mergeSeries( "PMMA_BJT" noMerge )
  mergeSeries( "pmmc_bjt" noMerge )
  mergeSeries( "PMMC_BJT" noMerge )
  mergeSeries( "phv_bjt" noMerge )
  mergeSeries( "PHV_BJT" noMerge )
  mergeSeries( "phhv_bjt" noMerge )
  mergeSeries( "PHHV_BJT" noMerge )

  mergeSeries( "nedam" noMerge )
  mergeSeries( "NEDAM" noMerge )
  mergeSeries( "pedam" noMerge )
  mergeSeries( "PEDAM" noMerge )
  mergeSeries( "nedam_bjt" noMerge )
  mergeSeries( "NEDAM_BJT" noMerge )
  mergeSeries( "pedam_bjt" noMerge )
  mergeSeries( "PEDAM_BJT" noMerge )

  mergeSeries( "mosvc" noMerge )
  mergeSeries( "mosvc3" noMerge )
  mergeSeries( "mosvci" noMerge )
  mergeSeries( "mosvci_m" noMerge )
  mergeSeries( "mosvc3i" noMerge )
  mergeSeries( "mosvc3i_m" noMerge )
  mergeSeries( "MOSVC" noMerge )
  mergeSeries( "MOSVC3" noMerge )
  mergeSeries( "MOSVCI" noMerge )
  mergeSeries( "MOSVCI_M" noMerge )
  mergeSeries( "MOSVC3I" noMerge )
  mergeSeries( "MOSVC3I_M" noMerge )

  mergeSeries( "nha3m" noMerge )
  mergeSeries( "NHA3M" noMerge )
  
  mergeSeries( RES noMerge )
    
  mergeSeries( BJT noMerge )

  mergeSeries( DIO noMerge )

  mergeSeries( "dphoc" noMerge )
  mergeSeries( "DPHOC" noMerge )
  mergeSeries( "dphoc0" noMerge )
  mergeSeries( "DPHOC0" noMerge )
  mergeSeries( "dphocfp" noMerge )
  mergeSeries( "DPHOCFP" noMerge )
  mergeSeries( "dphod" noMerge )
  mergeSeries( "DPHOD" noMerge )
  mergeSeries( "dphod0" noMerge )
  mergeSeries( "DPHOD0" noMerge )
  mergeSeries( "dphodfp" noMerge )
  mergeSeries( "DPHODFP" noMerge )

 ;;formGate( none ) ;;verhindert gate veriations (parallel_series)


; Parameter comparison

  ;;compareParameter( "cmm" compareMIMCAP )
  ;;compareParameter( "cdmm" compareMIMCAP )
  ;;compareParameter( "ctmm" compareMIMCAP )
  compareParameter( "cmm3" compareMIMCAP )
  compareParameter( "cmm3t" compareMIMCAP )
  compareParameter( "cmm4" compareMIMCAP )
  compareParameter( "cmm4t" compareMIMCAP )
  compareParameter( "cmm5t" compareMIMCAP )
  compareParameter( "cmm6t" compareMIMCAP )
  compareParameter( "cmmh3" compareMIMCAP )
  compareParameter( "cmmh3t" compareMIMCAP )
  compareParameter( "cmmh4" compareMIMCAP )
  compareParameter( "cmmh4t" compareMIMCAP )
  compareParameter( "cmmh5t" compareMIMCAP )
  compareParameter( "cmmh6t" compareMIMCAP )
  compareParameter( "cdmm4" compareMIMCAP )
  compareParameter( "cdmm4t" compareMIMCAP )
  compareParameter( "ctmm5" compareMIMCAP )
  compareParameter( "ctmm5t" compareMIMCAP )
  compareParameter( "cdmmh4" compareMIMCAP )
  compareParameter( "cdmmh4t" compareMIMCAP )
  compareParameter( "ctmmh5" compareMIMCAP )
  compareParameter( "ctmmh5t" compareMIMCAP )
  
  ;;compareParameter( "CMM" compareMIMCAP )
  ;;compareParameter( "CDMM" compareMIMCAP )
  ;;compareParameter( "CTMM" compareMIMCAP )
  compareParameter( "CMM3" compareMIMCAP )
  compareParameter( "CMM3T" compareMIMCAP )
  compareParameter( "CMM4" compareMIMCAP )
  compareParameter( "CMM4T" compareMIMCAP )
  compareParameter( "CMM5T" compareMIMCAP )
  compareParameter( "CMM6T" compareMIMCAP )
  compareParameter( "CMMH3" compareMIMCAP )
  compareParameter( "CMMH3T" compareMIMCAP )
  compareParameter( "CMMH4" compareMIMCAP )
  compareParameter( "CMMH4T" compareMIMCAP )
  compareParameter( "CMMH5T" compareMIMCAP )
  compareParameter( "CMMH6T" compareMIMCAP )
  compareParameter( "CDMM4" compareMIMCAP )
  compareParameter( "CDMM4T" compareMIMCAP )
  compareParameter( "CTMM5" compareMIMCAP )
  compareParameter( "CTMM5T" compareMIMCAP )
  compareParameter( "CDMMH4" compareMIMCAP )
  compareParameter( "CDMMH4T" compareMIMCAP )
  compareParameter( "CTMMH5" compareMIMCAP )
  compareParameter( "CTMMH5T" compareMIMCAP )

  compareParameter( "csandwt3" compareCAP )
  compareParameter( "csandwt4" compareCAP )
  compareParameter( "csandwt5" compareCAP )
  compareParameter( "CSANDWT3" compareCAP )
  compareParameter( "CSANDWT4" compareCAP )
  compareParameter( "CSANDWT5" compareCAP )

  compareParameter( "csf2p" compareCAP )
  compareParameter( "CSF2P" compareCAP )
  compareParameter( "csf3" compareCAP )
  compareParameter( "CSF3" compareCAP )
  compareParameter( "csf3p" compareCAP )
  compareParameter( "CSF3P" compareCAP )
  compareParameter( "csf4" compareCAP )
  compareParameter( "CSF4" compareCAP )
  compareParameter( "csft4" compareCAP )
  compareParameter( "CSFT4" compareCAP )
  compareParameter( "csf5" compareCAP )
  compareParameter( "CSF5" compareCAP )
  compareParameter( "csft5" compareCAP )
  compareParameter( "CSFT5" compareCAP )
  compareParameter( "csft6" compareCAP )
  compareParameter( "CSFT6" compareCAP )
  
  compareParameter( "csf3a" compareCAP )
  compareParameter( "CSF3A" compareCAP )
  compareParameter( "csf4a" compareCAP )
  compareParameter( "CSF4A" compareCAP )
  compareParameter( "csft4a" compareCAP )
  compareParameter( "CSFT4A" compareCAP )
  compareParameter( "csf5a" compareCAP )
  compareParameter( "CSF5A" compareCAP )
  compareParameter( "csft5a" compareCAP )
  compareParameter( "CSFT5A" compareCAP )
  compareParameter( "csft6a" compareCAP )
  compareParameter( "CSFT6A" compareCAP )

  compareParameter( "cpod" compareCAP )
  compareParameter( "cpod3" compareCAP )
  compareParameter( "cpodhv" compareCAP )
  compareParameter( "CPOD" compareCAP )
  compareParameter( "CPOD3" compareCAP )
  compareParameter( "CPODHV" compareCAP )

  compareParameter( MOS compareMOS )
  compareParameter( "nmma" compareMOS )
  compareParameter( "pmma" compareMOS )
  compareParameter( "NMMA" compareMOS )
  compareParameter( "PMMA" compareMOS )
  compareParameter( "nmmc" compareMOS )
  compareParameter( "nmmd" compareMOS )
  compareParameter( "pmmc" compareMOS )
  compareParameter( "NMMC" compareMOS )
  compareParameter( "NMMD" compareMOS )
  compareParameter( "PMMC" compareMOS )
  compareParameter( "nma" compareMOS )
  compareParameter( "pma" compareMOS )
  compareParameter( "NMA" compareMOS )
  compareParameter( "PMA" compareMOS )
  compareParameter( "nmc" compareMOS )
  compareParameter( "pmc" compareMOS )
  compareParameter( "NMC" compareMOS )
  compareParameter( "PMC" compareMOS )
  compareParameter( "nhhv" compareMOS )
  compareParameter( "phhv" compareMOS )
  compareParameter( "NHHV" compareMOS )
  compareParameter( "PHHV" compareMOS )
  compareParameter( "nhv" compareMOS )
  compareParameter( "phv" compareMOS )
  compareParameter( "NHV" compareMOS )
  compareParameter( "PHV" compareMOS )

  compareParameter( "nmma_bjt" compareMOS )
  compareParameter( "nmmc_bjt" compareMOS )
  compareParameter( "nmmd_bjt" compareMOS )
  compareParameter( "nma_bjt" compareMOS )
  compareParameter( "nmc_bjt" compareMOS )
  compareParameter( "nhhv_bjt" compareMOS )
  compareParameter( "nhv_bjt" compareMOS )
  compareParameter( "NMMA_BJT" compareMOS )
  compareParameter( "NMMC_BJT" compareMOS )
  compareParameter( "NMMD_BJT" compareMOS )
  compareParameter( "NMA_BJT" compareMOS )
  compareParameter( "NMC_BJT" compareMOS )
  compareParameter( "NHHV_BJT" compareMOS )
  compareParameter( "NHV_BJT" compareMOS )

  compareParameter( "pma_bjt" compareMOS )
  compareParameter( "PMA_BJT" compareMOS )
  compareParameter( "pmc_bjt" compareMOS )
  compareParameter( "PMC_BJT" compareMOS )
  compareParameter( "pmma_bjt" compareMOS )
  compareParameter( "PMMA_BJT" compareMOS )
  compareParameter( "pmmc_bjt" compareMOS )
  compareParameter( "PMMC_BJT" compareMOS )
  compareParameter( "phv_bjt" compareMOS )
  compareParameter( "PHV_BJT" compareMOS )
  compareParameter( "phhv_bjt" compareMOS )
  compareParameter( "PHHV_BJT" compareMOS )
    
  ;;compareParameter( "ndsi" compareMOS )
  compareParameter( "nds3i" compareMOS )
  compareParameter( "nedi" compareMOS )
  compareParameter( "nedia" compareMOS )
  compareParameter( "ped2" compareMOS )
  compareParameter( "ped" compareMOS )
  ;;compareParameter( "NDSI" compareMOS )
  compareParameter( "NDS3I" compareMOS )
  compareParameter( "NEDI" compareMOS )
  compareParameter( "NEDIA" compareMOS )
  compareParameter( "PED2" compareMOS )
  compareParameter( "PED" compareMOS )

  compareParameter( "nedi_bjt" compareMOS )
  compareParameter( "nedia_bjt" compareMOS )
  compareParameter( "ped2_bjt" compareMOS )
  compareParameter( "ped_bjt" compareMOS )
  compareParameter( "NEDI_BJT" compareMOS )
  compareParameter( "NEDIA_BJT" compareMOS )
  compareParameter( "PED2_BJT" compareMOS )
  compareParameter( "PED_BJT" compareMOS )

  compareParameter( "nhhvd" compareMOS )
  compareParameter( "NHHVD" compareMOS )
  compareParameter( "nhvd" compareMOS )
  compareParameter( "NHVD" compareMOS )

  compareParameter( "nhhvd_bjt" compareMOS )
  compareParameter( "NHHVD_BJT" compareMOS )
  compareParameter( "nhvd_bjt" compareMOS )
  compareParameter( "NHVD_BJT" compareMOS )

  compareParameter( "nedam" compareMOS )
  compareParameter( "NEDAM" compareMOS )
  compareParameter( "pedam" compareMOS )
  compareParameter( "PEDAM" compareMOS )
  compareParameter( "nedam_bjt" compareMOS )
  compareParameter( "NEDAM_BJT" compareMOS )
  compareParameter( "pedam_bjt" compareMOS )
  compareParameter( "PEDAM_BJT" compareMOS )

  compareParameter( "mosvc" compareMOS )
  compareParameter( "mosvc3" compareMOS )
  compareParameter( "mosvci" compareMOS )
  compareParameter( "mosvci_m" compareMOS )
  compareParameter( "mosvc3i" compareMOS )
  compareParameter( "mosvc3i_m" compareMOS )
  compareParameter( "MOSVC" compareMOS )
  compareParameter( "MOSVC3" compareMOS )
  compareParameter( "MOSVCI" compareMOS )
  compareParameter( "MOSVCI_M" compareMOS )
  compareParameter( "MOSVC3I" compareMOS )
  compareParameter( "MOSVC3I_M" compareMOS )

  compareParameter( "nha3m" compareMOS )
  compareParameter( "NHA3M" compareMOS )
  compareParameter( "cnn_otpa" compareCAP )
  compareParameter( "CNN_OTPA" compareCAP )
  
  compareParameter( RES compareRES )
  compareParameter( "s_res" doNotCompareRes )
  compareParameter( "S_RES" doNotCompareRes )
  
  
  ;;compareParameter( BJT compareBJT )
  compareParameter( "qnva" compareBJT_l )
  compareParameter( "qnvb" compareBJT_l )
  compareParameter( "qnvc" compareBJT_l )
  compareParameter( "qnvz" compareBJT_l )
  compareParameter( "qpva" compareBJT )
  compareParameter( "qpvb" compareBJT )
  compareParameter( "qpvc" compareBJT )
  compareParameter( "qpva3" compareBJT )
  compareParameter( "qpvb3" compareBJT )
  compareParameter( "qpvc3" compareBJT )
  compareParameter( "QNVA" compareBJT_l )
  compareParameter( "QNVB" compareBJT_l )
  compareParameter( "QNVC" compareBJT_l )
  compareParameter( "QNVZ" compareBJT_l )
  compareParameter( "QPVA" compareBJT )
  compareParameter( "QPVB" compareBJT )
  compareParameter( "QPVC" compareBJT )
  compareParameter( "QPVA3" compareBJT )
  compareParameter( "QPVB3" compareBJT )
  compareParameter( "QPVC3" compareBJT )
  compareParameter( "qpvhscr" compareBJT_l )
  compareParameter( "QPVHSCR" compareBJT_l )
  compareParameter( "qpvascr" compareBJT_l )
  compareParameter( "QPVASCR" compareBJT_l )
  compareParameter( "qpvhbscr" compareBJT_l )
  compareParameter( "QPVHBSCR" compareBJT_l )

  compareParameter( "qnvam" compareBJT )
  compareParameter( "QNVAM" compareBJT )
  
  compareParameter( DIO compareDIO )
  
  compareParameter( "dphoc" compareDPHO )
  compareParameter( "DPHOC" compareDPHO )
  compareParameter( "dphoc0" compareDPHO )
  compareParameter( "DPHOC0" compareDPHO )
  compareParameter( "dphocfp" compareDPHO )
  compareParameter( "DPHOCFP" compareDPHO )
  compareParameter( "dphod" compareDPHO )
  compareParameter( "DPHOD" compareDPHO )
  compareParameter( "dphod0" compareDPHO )
  compareParameter( "DPHOD0" compareDPHO )
  compareParameter( "dphodfp" compareDPHO )
  compareParameter( "DPHODFP" compareDPHO )

  bind( cell("PED2" "ped2") net("B" "SB") )
  bind( cell("ped2" "ped2") net("B" "SB") )
  bind( cell("PED" "ped") net("B" "SB") )
  bind( cell("ped" "ped") net("B" "SB") )
  bind( cell("NEDI" "nedi") net("B" "SB") )
  bind( cell("nedi" "nedi") net("B" "SB") )
  bind( cell("NEDIA" "nedia") net("B" "SB") )
  bind( cell("nedia" "nedia") net("B" "SB") )
  bind( cell("PED2_BJT" "ped2_bjt") net("B" "SB") )
  bind( cell("ped2_bjt" "ped2_bjt") net("B" "SB") )
  bind( cell("PED_BJT" "ped_bjt") net("B" "SB") )
  bind( cell("ped_bjt" "ped_bjt") net("B" "SB") )
  bind( cell("NEDI_BJT" "nedi_bjt") net("B" "SB") )
  bind( cell("nedi_bjt" "nedi_bjt") net("B" "SB") )
  bind( cell("NEDIA_BJT" "nedia_bjt") net("B" "SB") )
  bind( cell("nedia_bjt" "nedia_bjt") net("B" "SB") )
  bind( cell("NMMA" "nmma") )
  bind( cell("nmma" "nmma") )
  bind( cell("PMMA" "pmma") )
  bind( cell("pmma" "pmma") )
  bind( cell("NMMC" "nmmc") )
  bind( cell("nmmc" "nmmc") )
  bind( cell("NMMD" "nmmd") )
  bind( cell("nmmd" "nmmd") )
  bind( cell("PMMC" "pmmc") )
  bind( cell("pmmc" "pmmc") )
  bind( cell("NMA" "nma") )
  bind( cell("nma" "nma") )
  bind( cell("PMA" "pma") )
  bind( cell("pma" "pma") )
  bind( cell("NMC" "nmc") )
  bind( cell("nmc" "nmc") )
  bind( cell("PMC" "pmc") )
  bind( cell("pmc" "pmc") )
  bind( cell("NHHV" "nhhv") )
  bind( cell("nhhv" "nhhv") )
  bind( cell("PHHV" "phhv") )
  bind( cell("phhv" "phhv") )
  bind( cell("NHV" "nhv") )
  bind( cell("nhv" "nhv") )
  bind( cell("PHV" "phv") )
  bind( cell("phv" "phv") )

  bind( cell("NHHVD" "nhhvd") )
  bind( cell("nhhvd" "nhhvd") )
  bind( cell("NHVD" "nhvd") )
  bind( cell("nhvd" "nhvd") )

  bind( cell("NMMA_BJT" "nmma_bjt") )
  bind( cell("nmma_bjt" "nmma_bjt") )
  bind( cell("NMMC_BJT" "nmmc_bjt") )
  bind( cell("nmmc_bjt" "nmmc_bjt") )
  bind( cell("NMMD_BJT" "nmmd_bjt") )
  bind( cell("nmmd_bjt" "nmmd_bjt") )
  bind( cell("NMA_BJT" "nma_bjt") )
  bind( cell("nma_bjt" "nma_bjt") )
  bind( cell("NMC_BJT" "nmc_bjt") )
  bind( cell("nmc_bjt" "nmc_bjt") )
  bind( cell("NHHV_BJT" "nhhv_bjt") )
  bind( cell("nhhv_bjt" "nhhv_bjt") )
  bind( cell("NHV_BJT" "nhv_bjt") )
  bind( cell("nhv_bjt" "nhv_bjt") )
  bind( cell("NHHVD_BJT" "nhhvd_bjt") )
  bind( cell("nhhvd_bjt" "nhhvd_bjt") )
  bind( cell("NHVD_BJT" "nhvd_bjt") )
  bind( cell("nhvd_bjt" "nhvd_bjt") )

  bind( cell("NHA3M" "nha3m") )
  bind( cell("nha3m" "nha3m") )

  ;;bind( cell("dphoc" "dphoc") )
  ;;bind( cell("DPHOC" "dphoc") )
  ;;bind( cell("dphoc0" "dphoc0") )
  ;;bind( cell("DPHOC0" "dphoc0") )
  ;;bind( cell("dphocfp" "dphocfp") )
  ;;bind( cell("DPHOCFP" "dphocfp") )
  ;;bind( cell("dphod" "dphod") )
  ;;bind( cell("DPHOD" "dphod") )
  ;;bind( cell("dphod0" "dphod0") )
  ;;bind( cell("DPHOD0" "dphod0") )
  ;;bind( cell("dphodfp" "dphodfp") )
  ;;bind( cell("DPHODFP" "dphodfp") )
/*  
  bind( cell("NE3I_M_6" "ne3i_m_6") )
  bind( cell("ne3i_m_6" "ne3i_m_6") )
  bind( cell("NE3I_6" "ne3i_6") )
  bind( cell("ne3i_6" "ne3i_6") )
  bind( cell("NEI_M_6" "nei_m_6") )
  bind( cell("nei_m_6" "nei_m_6") )
  bind( cell("NEI_6" "nei_6") )
  bind( cell("nei_6" "nei_6") )
  bind( cell("NELI_M_6" "neli_m_6") )
  bind( cell("neli_m_6" "neli_m_6") )
  bind( cell("NELI_6" "neli_6") )
  bind( cell("neli_6" "neli_6") )
  bind( cell("ND3I_M_6" "nd3i_m_6") )
  bind( cell("nd3i_m_6" "nd3i_m_6") )
  bind( cell("ND3I_6" "nd3i_6") )
  bind( cell("nd3i_6" "nd3i_6") )
*/  
layout(
  mosDevice("pe_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pel_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pei_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pei_m_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3i_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3i_m_5" ("D" "G" "S" "B" "SB"))
  mosDevice("peli_5" ("D" "G" "S" "B" "SB"))
  mosDevice("peli_m_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3ln_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3lni_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3lni_m_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pesvt_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pesvti_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pesvti_m_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3lna_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3lnai_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3lnai_m_5" ("D" "G" "S" "B" "SB"))  
  mosDevice("nei_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("nei_m_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("ne3i_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("ne3i_m_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("neli_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("neli_m_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("nd3i_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("nd3i_m_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("nelnai_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("nelnai_m_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("nesvti_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("nesvti_m_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("ne3lnai_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("ne3lnai_m_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("pma_bjt" ("D" "G" "S" "B" "SB"))
  )
schematic(
  mosDevice("pe_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pel_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pei_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pei_m_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3i_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3i_m_5" ("D" "G" "S" "B" "SB"))
  mosDevice("peli_5" ("D" "G" "S" "B" "SB"))
  mosDevice("peli_m_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3ln_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3lni_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3lni_m_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pesvt_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pesvti_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pesvti_m_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3lna_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3lnai_5" ("D" "G" "S" "B" "SB"))
  mosDevice("pe3lnai_m_5" ("D" "G" "S" "B" "SB"))  
  mosDevice("nei_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("nei_m_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("ne3i_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("ne3i_m_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("neli_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("neli_m_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("nd3i_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("nd3i_m_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("nelnai_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("nelnai_m_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("nesvti_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("nesvti_m_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("ne3lnai_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("ne3lnai_m_6" ("D" "G" "S" "B" "NW" "SB"))
  mosDevice("pma_bjt" ("D" "G" "S" "B" "SB"))
  genericDevice("dphoc")
  genericDevice("dphoc0")
  genericDevice("dphocfp")
  genericDevice("dphod")
  genericDevice("dphod0")
  genericDevice("dphodfp")
  genericDevice("phhv_bjt")
  genericDevice("phv_bjt")
  genericDevice("pmmc_bjt")
  genericDevice("pmc_bjt")
  genericDevice("pmma_bjt")
  genericDevice("nedam")
  genericDevice("pedam")
  genericDevice("nedam_bjt")
  genericDevice("pedam_bjt")
  genericDevice("pedama")
  genericDevice("pedama_bjt")
  genericDevice("mosvc")
  genericDevice("mosvc3")
  genericDevice("mosvci")
  genericDevice("mosvci_m")
  genericDevice("mosvc3i")
  genericDevice("mosvc3i_m")
  genericDevice("tag_60v")
  genericDevice("tag_25v")
  )
  
) ;end avCompareRules


;----------------------------------------------------------------------------
; avCompareRules Section from Run Submit Form
; Created by the Assura UI
;----------------------------------------------------------------------------

avCompareRules(
schematic(
netlist( dfII "/home/ykhuang/research/AssuraLVS/5bit_BinaryWeightedMirror_ST_LVS.vlr" )
)
)


avLVS()

